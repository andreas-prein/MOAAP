 
The provided variables allow tracking the following phenomena
 
|  phenomenon  | tracking |
---------------------------
   Jetstream   |   no
   PSL CY/ACY  |   no
   Z500 CY/ACY |   no
   COLs        |   no
   IVT ARs     |   no
   MS ARs      |   no
   Fronts      |   no
   TCs         |   no
   MCSs        |   yes
   clouds      |   yes
   Equ. Waves  |   no
---------------------------
 
======> 'check if Tb objects qualify as MCS (or selected storm type)
        track  clouds
        8339 cloud object found
        fast way that removes obviously too small objects
        92 cloud object remaining
        break up long living cloud shield objects with watershed that have many elements
            Loop over 4280 objects
            Loop over 100 objects
        00:00:09.82
======> 'track high clouds in Tb field by excluding MCS objects
        track  clouds
        break up long living cloud shield objects with wathershedding
        make sure that each object has at least one grid cell with more than min_pr threshold of precipitation
            Loop over 878 objects
        00:00:04.47
 
Save the object masks into a joint netCDF
Saved: moaap_output/202107_ERA5_ObjectMasks__dt-1h_MOAAP-masks.nc
        00:00:04.99
Wrote profile results to '2d_vs_3d.py.lprof'
Timer unit: 1e-06 s

Total time: 0.13784 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: clean_up_objects at line 2158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2158                                           @profile
  2159                                           def clean_up_objects(DATA,
  2160                                                                dT,
  2161                                                                min_tsteps = 0,
  2162                                                                obj_splitmerge = None):
  2163                                               """ Function to remove objects that are too short lived
  2164                                                   and to numerrate the object from 1...N
  2165                                               """
  2166                                               
  2167         1      78567.3  78567.3     57.0      object_indices = ndimage.find_objects(DATA)
  2168         1       6940.2   6940.2      5.0      MaxOb = np.max(DATA)
  2169         1          4.4      4.4      0.0      MinLif = int(24 / dT)  # min lifetime of object to be split
  2170         1          1.7      1.7      0.0      AVmax = 1.5
  2171                                           
  2172         1         11.5     11.5      0.0      id_translate = np.zeros((len(object_indices),2))
  2173         1      34097.7  34097.7     24.7      objectsTMP = np.zeros_like(DATA)
  2174         1          5.5      5.5      0.0      ii = 1
  2175      3672       1906.1      0.5      1.4      for obj in range(len(object_indices)):
  2176      3671       1904.1      0.5      1.4          if object_indices[obj] != None:
  2177       100         93.4      0.9      0.1              if object_indices[obj][0].stop - object_indices[obj][0].start >= min_tsteps / dT:
  2178       100       2810.8     28.1      2.0                  Obj_tmp = np.copy(objectsTMP[object_indices[obj]])
  2179       100       5450.4     54.5      4.0                  Obj_tmp[DATA[object_indices[obj]] == obj+1] = ii
  2180       100       1271.4     12.7      0.9                  objectsTMP[object_indices[obj]] = Obj_tmp
  2181       100         93.8      0.9      0.1                  id_translate[obj,0] = obj+1
  2182       100         67.6      0.7      0.0                  id_translate[obj,1] = ii
  2183       100         57.2      0.6      0.0                  ii = ii + 1
  2184                                                       else:
  2185                                                           id_translate[obj,0] = obj+1
  2186                                                           id_translate[obj,1] = -1
  2187                                                   else:
  2188      3571       2361.4      0.7      1.7              id_translate[obj,0] = obj+1
  2189      3571       2188.2      0.6      1.6              id_translate[obj,1] = -1
  2190                                           
  2191                                               # adjust the directory strucutre accordingly
  2192         1          2.1      2.1      0.0      obj_splitmerge_clean = {}
  2193                                           
  2194         1          1.9      1.9      0.0      if obj_splitmerge != None:
  2195                                                   id_translate = id_translate.astype(int)  
  2196                                                   keys = np.copy(list(obj_splitmerge.keys()))
  2197                                                   for jj in range(len(keys)):
  2198                                                       obj_loc = np.where(int(list(keys)[jj]) == id_translate[:,0])[0][0]
  2199                                                       if id_translate[obj_loc,1] == -1:
  2200                                                           del obj_splitmerge[list(keys)[jj]]
  2201                                           
  2202                                                   # loop over objects and relable their indices if nescessary
  2203                                                   obj_splitmerge_clean = {}
  2204                                                   keys = np.copy(list(obj_splitmerge.keys()))
  2205                                                   core_translate = np.isin(id_translate[:,0], keys.astype(int))
  2206                                                   id_translate = id_translate[core_translate,:]
  2207                                                   for jj in range(len(keys)):
  2208                                                       obj_loc = np.where(int(list(keys)[jj]) == id_translate[:,0])[0][0]
  2209                                                       mergsplit = np.array(obj_splitmerge[keys[jj]])
  2210                                                       for kk in range(id_translate.shape[0]):
  2211                                                           mergsplit[np.isin(mergsplit, id_translate[kk,0])] = id_translate[kk,1]
  2212                                                       obj_splitmerge_clean[str(int(id_translate[obj_loc,1]))] = mergsplit
  2213                                                   
  2214         1          3.9      3.9      0.0      return objectsTMP, obj_splitmerge_clean

Total time: 5.68103 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: mcs_tb_tracking at line 2946

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  2946                                           @profile
  2947                                           def mcs_tb_tracking(
  2948                                                               tb,
  2949                                                               pr,
  2950                                                               SmoothSigmaC,
  2951                                                               Pthreshold,
  2952                                                               CL_Area,
  2953                                                               CL_MaxT,
  2954                                                               Cthreshold,
  2955                                                               MinAreaC,
  2956                                                               MinTimeC,
  2957                                                               MCS_minPR,
  2958                                                               MCS_minTime,
  2959                                                               MCS_Minsize,
  2960                                                               dT,
  2961                                                               Area,
  2962                                                               connectLon,
  2963                                                               Gridspacing,
  2964                                                               breakup = 'watershed',  # method for breaking up connected objects [watershed, breakup]
  2965                                                              ):
  2966                                           
  2967         1          4.3      4.3      0.0      print('        track  clouds')
  2968         1         17.3     17.3      0.0      rgiObj_Struct=np.zeros((3,3,3)); rgiObj_Struct[:,:,:]=1
  2969                                               # Csmooth=gaussian_filter(tb, sigma=(0,SmoothSigmaC,SmoothSigmaC))
  2970         1      17848.2  17848.2      0.3      Cmask = (tb <= Cthreshold)
  2971         1     224778.5 224778.5      4.0      rgiObjectsC, nr_objectsUD = ndimage.label(Cmask, structure=rgiObj_Struct)
  2972         1         13.9     13.9      0.0      print('        '+str(nr_objectsUD)+' cloud object found')
  2973                                           
  2974                                               # if connectLon == 1:
  2975                                               #     # connect objects over date line
  2976                                               #     rgiObjectsC = ConnectLon(rgiObjectsC)
  2977                                                   
  2978                                                   
  2979         1          2.1      2.1      0.0      print('        fast way that removes obviously too small objects')
  2980         1      86257.1  86257.1      1.5      unique, counts = np.unique(rgiObjectsC, return_counts=True)
  2981         1         56.1     56.1      0.0      min_vol = np.round((CL_Area * (MCS_minTime/dT)) / ((Gridspacing / 1000.)**2)) # minimum grid cells requ. for MCS
  2982         1         77.3     77.3      0.0      remove = unique[counts < min_vol]
  2983         1     105729.2 105729.2      1.9      rgiObjectsC[np.isin(rgiObjectsC, remove)] = 0
  2984                                               
  2985         1     231855.7 231855.7      4.1      C_objects, nr_objectsUD = ndimage.label(rgiObjectsC, structure=rgiObj_Struct)
  2986         1         13.5     13.5      0.0      print('        '+str(nr_objectsUD)+' cloud object remaining')
  2987                                               
  2988                                               
  2989                                           #     print('        remove too small clouds')
  2990                                           #     Objects=ndimage.find_objects(rgiObjectsC)
  2991                                               
  2992                                           #     rgiAreaObj = np.array([[np.sum(Area[Objects[ob][1],Objects[ob][2]][rgiObjectsC[Objects[ob]][tt,:,:] == ob+1]) for tt in range(rgiObjectsC[Objects[ob]].shape[0])] for ob in range(nr_objectsUD)])
  2993                                           
  2994                                           #     # rgiVolObjC=np.array([np.sum(rgiObjectsC[Objects[ob]] == ob+1) for ob in range(nr_objectsUD)])
  2995                                           
  2996                                           #     # create final object array
  2997                                           #     C_objects=np.copy(rgiObjectsC); C_objects[:]=0
  2998                                           #     ii = 1
  2999                                           #     for ob in tqdm(range(len(rgiAreaObj))):
  3000                                           #         try:
  3001                                           #             AreaTest = np.max(np.convolve(np.array(rgiAreaObj[ob]) >= MinAreaC*1000**2, np.ones(int(MinTimeC/dT)), mode='valid'))
  3002                                           #         except:
  3003                                           #             stop()
  3004                                           #         if (AreaTest == int(MinTimeC/dT)) & (len(rgiAreaObj[ob]) >=int(MinTimeC/dT)):
  3005                                           #         # if rgiVolObjC[ob] >= MinAreaC:
  3006                                           #             C_objects[rgiObjectsC == (ob+1)] = ii
  3007                                           #             ii = ii + 1
  3008                                           
  3009         1          3.8      3.8      0.0      print('        break up long living cloud shield objects with '+breakup+' that have many elements')
  3010         1          1.7      1.7      0.0      if breakup == 'breakup':
  3011                                                   C_objects, object_split = BreakupObjects(C_objects,
  3012                                                                               int(MinTimeC/dT),
  3013                                                                               dT)
  3014         1          1.3      1.3      0.0      elif breakup == 'watershed':
  3015                                                   # C_objects = watersheding(C_objects,
  3016                                                   #                6,  # at least six grid cells apart 
  3017                                                   #                1)
  3018         1          0.8      0.8      0.0          threshold=1
  3019         1         16.0     16.0      0.0          min_dist=int(((CL_Area/np.pi)**0.5)/(Gridspacing/1000))*2
  3020         1      36801.9  36801.9      0.6          tb_masked = np.copy(tb)
  3021                                                   # we have to make minima (cold cloud tops) to maxima
  3022         1      42136.7  42136.7      0.7          tb_masked = tb_masked * -1
  3023                                                   # tb_masked = tb_masked + np.nanmin(tb_masked)
  3024                                                   # tb_masked[C_objects == 0] = 0
  3025         2    3796611.2  1.9e+06     66.8          C_objects = watershed_3d_overlap(
  3026         1      41528.7  41528.7      0.7                  tb * -1,
  3027         1          3.2      3.2      0.0                  Cthreshold * -1,
  3028         1          1.0      1.0      0.0                  Cthreshold * -1, #CL_MaxT * -1,
  3029         1          0.9      0.9      0.0                  min_dist,
  3030         1          1.2      1.2      0.0                  dT,
  3031         1          0.8      0.8      0.0                  mintime = MinTimeC,
  3032         1          1.1      1.1      0.0                  connectLon = connectLon,
  3033         1          1.3      1.3      0.0                  extend_size_ratio = 0.10
  3034                                                           )
  3035                                                   
  3036                                               # if connectLon == 1:
  3037                                               #     print('        connect cloud objects over date line')
  3038                                               #     C_objects = ConnectLon_on_timestep(C_objects)
  3039                                           
  3040                                               # check if precipitation object is from an MCS
  3041         1      95119.6  95119.6      1.7      object_indices = ndimage.find_objects(C_objects)
  3042         1         37.5     37.5      0.0      MCS_objects_Tb = np.zeros(C_objects.shape,dtype=int)
  3043                                           
  3044      4281      24823.8      5.8      0.4      for iobj,_ in tqdm(enumerate(object_indices)):
  3045      4280       2615.1      0.6      0.0          if object_indices[iobj] is None:
  3046       708        365.7      0.5      0.0              continue
  3047                                           
  3048      3572       2170.8      0.6      0.0          time_slice = object_indices[iobj][0]
  3049      3572       1985.6      0.6      0.0          lat_slice  = object_indices[iobj][1]
  3050      3572       1928.9      0.5      0.0          lon_slice  = object_indices[iobj][2]
  3051                                           
  3052      3572       3763.2      1.1      0.1          tb_object_slice= C_objects[object_indices[iobj]]
  3053      3572      58308.0     16.3      1.0          tb_object_act = np.where(tb_object_slice==iobj+1,True,False)
  3054      3572       2671.4      0.7      0.0          if len(tb_object_act) < MCS_minTime:
  3055      1307        687.8      0.5      0.0              continue
  3056                                           
  3057      2265       2037.4      0.9      0.0          tb_slice =  tb[object_indices[iobj]]
  3058      2265      27909.6     12.3      0.5          tb_act = np.copy(tb_slice)
  3059      2265      20934.8      9.2      0.4          tb_act[~tb_object_act] = np.nan
  3060                                           
  3061      2265       1957.0      0.9      0.0          bt_object_slice = C_objects[object_indices[iobj]]
  3062      2265      17192.6      7.6      0.3          bt_object_act = np.copy(bt_object_slice)
  3063      2265      18255.8      8.1      0.3          bt_object_act[~tb_object_act] = 0
  3064                                           
  3065      2265      65024.8     28.7      1.1          area_act = np.tile(Area[lat_slice, lon_slice], (tb_act.shape[0], 1, 1))
  3066      2265      17752.0      7.8      0.3          area_act[~tb_object_act] = 0
  3067                                           
  3068                                                   ### Calculate cloud properties
  3069      2265      37601.6     16.6      0.7          tb_size = np.array(np.sum(area_act,axis=(1,2)))
  3070      2265      43270.0     19.1      0.8          tb_min = np.array(np.nanmin(tb_act,axis=(1,2)))
  3071                                           
  3072                                                   ### Calculate precipitation properties
  3073      2265      28876.1     12.7      0.5          pr_act = np.copy(pr[object_indices[iobj]])
  3074      2265      30482.3     13.5      0.5          pr_act[tb_object_act == 0] = np.nan
  3075                                           
  3076      2265      39128.4     17.3      0.7          pr_peak_act = np.array(np.nanmax(pr_act,axis=(1,2)))
  3077                                           
  3078      2265       7603.8      3.4      0.1          pr_region_act = pr_act >= Pthreshold #*dT
  3079      2265      60390.3     26.7      1.1          area_act = np.tile(Area[lat_slice, lon_slice], (tb_act.shape[0], 1, 1))
  3080      2265      16691.5      7.4      0.3          area_act[~pr_region_act] = 0
  3081      2265      39644.2     17.5      0.7          pr_under_cloud = np.array(np.sum(area_act,axis=(1,2)))/1000**2 
  3082                                           
  3083                                                   # Test if object classifies as MCS
  3084      2265      69949.7     30.9      1.2          tb_size_test = np.max(np.convolve((tb_size / 1000**2 >= CL_Area), np.ones(MCS_minTime), 'valid') / MCS_minTime) == 1
  3085      2265      34958.6     15.4      0.6          tb_overshoot_test = np.max((tb_min  <= CL_MaxT )) == 1
  3086      2265      58532.4     25.8      1.0          pr_peak_test = np.max(np.convolve((pr_peak_act >= MCS_minPR ), np.ones(MCS_minTime), 'valid') / MCS_minTime) ==1
  3087      2265      32525.4     14.4      0.6          pr_area_test = np.max((pr_under_cloud >= MCS_Minsize)) == 1
  3088      2265       1244.0      0.5      0.0          MCS_test = (
  3089      9060       5682.5      0.6      0.1                      tb_size_test
  3090      2265       1155.6      0.5      0.0                      & tb_overshoot_test
  3091      2265       1102.8      0.5      0.0                      & pr_peak_test
  3092      2265       1083.4      0.5      0.0                      & pr_area_test
  3093                                                   )
  3094                                           
  3095                                                   # assign unique object numbers
  3096      2265      11576.2      5.1      0.2          tb_object_act = np.array(tb_object_act).astype(int)
  3097      2265      22536.1      9.9      0.4          tb_object_act[tb_object_act == 1] = iobj + 1
  3098                                           
  3099                                           #         window_length = int(MCS_minTime / dT)
  3100                                           #         moving_averages = np.convolve(MCS_test, np.ones(window_length), 'valid') / window_length
  3101                                           
  3102      2265       6262.7      2.8      0.1          if MCS_test == 1:
  3103       100       3751.9     37.5      0.1              TMP = np.copy(MCS_objects_Tb[object_indices[iobj]])
  3104       100       1438.2     14.4      0.0              TMP = TMP + tb_object_act
  3105       100      28433.9    284.3      0.5              MCS_objects_Tb[object_indices[iobj]] = TMP
  3106                                           
  3107                                                   else:
  3108                                                       # print([tb_size_test,tb_overshoot_test,pr_peak_test,pr_area_test])
  3109      2165       1371.0      0.6      0.0              continue
  3110                                           
  3111         2     146424.7  73212.3      2.6      MCS_objects_Tb, _ = clean_up_objects(MCS_objects_Tb,
  3112         1          0.9      0.9      0.0                                             dT,
  3113         1          1.5      1.5      0.0                                             min_tsteps=int(MCS_minTime/dT))
  3114                                           
  3115         1          7.3      7.3      0.0      return MCS_objects_Tb, C_objects

Total time: 3.14666 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: cloud_tracking at line 3119

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  3119                                           @profile
  3120                                           def cloud_tracking(
  3121                                               tb,
  3122                                               pr,
  3123                                               # MCS_obj,
  3124                                               connectLon,
  3125                                               Gridspacing,
  3126                                               dT,
  3127                                               tb_threshold = 241,
  3128                                               tb_overshoot = 235,
  3129                                               erosion_disk = 1.5,
  3130                                               min_dist = 8
  3131                                               ):
  3132                                               
  3133                                               """
  3134                                               Tracks clouds from hourly or sub-hourly brightness temperature data.
  3135                                               Calculates cloud statistics, including their precipitation (pr) properties if pr is provided.
  3136                                           
  3137                                               Args:
  3138                                                   tb (float): brightness temperature of dimension [time,lat,lon]
  3139                                                   connectLon (bol): 1 means that clouds should be connected accross date line
  3140                                                   Gridspacing (float): average horizontal grid spacing in [m]
  3141                                                   tb_threshold (float, optional): tb threshold to define cloud mask. Default is "241".
  3142                                                   cloud_overshoot (float, optional): tb threshold to find local minima for watershedding. Default is "235".
  3143                                                   erosion_disk (float, optional): reduction of next timestep mask for temporal connection of features. Larger values result in more erosion and can remove smaller clouds. The default is "0.15".
  3144                                                   min_dist (int, optional): minimum distance in grid cells between two tb minima (overshoots). The default is "8".
  3145                                           
  3146                                               Returns:
  3147                                                   float: The product of `a` and `b`.
  3148                                               """
  3149                                           
  3150         1          5.2      5.2      0.0      CL_Area = min_dist * Gridspacing
  3151         1          1.7      1.7      0.0      breakup = 'watershed'
  3152                                               
  3153         1          7.3      7.3      0.0      print('        track  clouds')
  3154         1      16950.1  16950.1      0.5      Cmask = (tb <= tb_threshold)
  3155                                               
  3156         1          5.0      5.0      0.0      print('        break up long living cloud shield objects with wathershedding')
  3157                                               
  3158         1         12.8     12.8      0.0      min_dist=int(((CL_Area/np.pi)**0.5)/(Gridspacing/1000))*2
  3159         1      36015.7  36015.7      1.1      tb_masked = np.copy(tb)
  3160                                               # we have to make minima (cold cloud tops) to maxima
  3161         1      41277.6  41277.6      1.3      tb_masked = tb_masked * -1
  3162                                               # tb_masked = tb_masked + np.nanmin(tb_masked)
  3163                                               # tb_masked[C_objects == 0] = 0
  3164         2    2831921.2 1.42e+06     90.0      cloud_objects = watershed_3d_overlap(
  3165         1      40589.9  40589.9      1.3              tb * -1,
  3166         1          2.5      2.5      0.0              tb_threshold * -1,
  3167         1          1.3      1.3      0.0              tb_overshoot * -1, #CL_MaxT * -1,
  3168         1          1.1      1.1      0.0              min_dist,
  3169         1          0.9      0.9      0.0              dT,
  3170         1          0.9      0.9      0.0              mintime = 0,
  3171         1          0.7      0.7      0.0              connectLon = connectLon,
  3172         1          1.0      1.0      0.0              extend_size_ratio = 0.10,
  3173                                                       # erosion_disk = erosion_disk
  3174                                                       )
  3175                                           
  3176         1          7.9      7.9      0.0      print("        make sure that each object has at least one grid cell with more than min_pr threshold of precipitation")
  3177         1          1.6      1.6      0.0      min_pr = 2 * dT # minimum precipitation in [mm/h]
  3178         1      90656.2  90656.2      2.9      object_indices = ndimage.find_objects(cloud_objects)
  3179       879       5784.1      6.6      0.2      for iobj,_ in tqdm(enumerate(object_indices)):
  3180       878        541.0      0.6      0.0          if object_indices[iobj] is None:
  3181       140         75.7      0.5      0.0              continue
  3182       738        931.4      1.3      0.0          pr_object_slice= cloud_objects[object_indices[iobj]]
  3183       738      31619.6     42.8      1.0          pr_object_act = np.where(pr_object_slice==iobj+1,True,False)
  3184                                                       
  3185       738        735.6      1.0      0.0          pr_slice =  pr[object_indices[iobj]]
  3186       738      16806.4     22.8      0.5          pr_act = np.copy(pr_slice)
  3187       738      15694.1     21.3      0.5          pr_act[~pr_object_act] = np.nan
  3188       738      13874.0     18.8      0.4          if np.nanmax(pr_act) < min_pr:
  3189       218       3138.7     14.4      0.1              cloud_objects[object_indices[iobj]][cloud_objects[object_indices[iobj]] == iobj+1] = 0
  3190                                           
  3191         1          2.5      2.5      0.0      return cloud_objects

Total time: 0 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: watershed_2d_overlap at line 4091

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4091                                           @profile
  4092                                           # This function performs watershedding on 2D anomaly fields and
  4093                                           # succeeds an older version of this function (watershed_2d_overlap_temp_discontin).
  4094                                           # This function uses spatially reduced watersheds from the previous time step as seed for the
  4095                                           # current time step, which improves temporal consistency of features.
  4096                                           def watershed_2d_overlap(data, # 3D matrix with data for watershedding [np.array]
  4097                                                                    object_threshold, # float to create binary object mast [float]
  4098                                                                    max_treshold, # value for identifying max. points for spreading [float]
  4099                                                                    min_dist, # minimum distance (in grid cells) between maximum points [int]
  4100                                                                    dT, # time interval in hours [int]
  4101                                                                    mintime = 24, # minimum time an object has to exist in dT [int]
  4102                                                                    connectLon = 0,  # do we have to track features over the date line?
  4103                                                                    extend_size_ratio = 0.25, # if connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs
  4104                                                                    erosion_disk = 3.5): 
  4105                                           
  4106                                               from scipy import ndimage as ndi
  4107                                               from skimage.feature import peak_local_max
  4108                                               from skimage.segmentation import watershed
  4109                                               from scipy.ndimage import gaussian_filter
  4110                                               from Tracking_Functions import clean_up_objects
  4111                                               from Tracking_Functions import ConnectLon_on_timestep
  4112                                               
  4113                                               if connectLon == 1:
  4114                                                   axis = 1
  4115                                                   extension_size = int(data.shape[1] * extend_size_ratio)
  4116                                                   data = np.concatenate(
  4117                                                           [data[:, :, -extension_size:], data, data[:, :, :extension_size]], axis=2
  4118                                                       )
  4119                                               data_2d_watershed = np.copy(data); data_2d_watershed[:] = np.nan
  4120                                               for tt in tqdm(range(data.shape[0])):
  4121                                                   image = data[tt,:] >= object_threshold
  4122                                                   data_t0 = data[tt,:,:]
  4123                                           
  4124                                                   # get maximum precipitation over three time steps to make fields more coherant
  4125                                                   coords = peak_local_max(data_t0, 
  4126                                                                           min_distance = min_dist,
  4127                                                                           threshold_abs = max_treshold,
  4128                                                                           labels = image
  4129                                                                          )
  4130                                               
  4131                                                   mask = np.zeros(data_t0.shape, dtype=bool)
  4132                                                   mask[tuple(coords.T)] = True
  4133                                                   markers, _ = ndi.label(mask)
  4134                                               
  4135                                                   if tt != 0:
  4136                                                       # allow markers to change a bit from time to time and 
  4137                                                       # introduce new markers if they have strong enough max/min and
  4138                                                       # are far enough away from existing objects
  4139                                                       from skimage.segmentation import find_boundaries
  4140                                                       from skimage.morphology import erosion, square, disk, rectangle
  4141                                                       boundaries = find_boundaries(data_2d_watershed[tt-1,:,:].astype("int"), mode='outer')
  4142                                                       # Set boundaries to zero in the markers
  4143                                                       separated_markers = np.copy(data_2d_watershed[tt-1,:,:].astype("int"))
  4144                                                       separated_markers[boundaries] = 0
  4145                                                       from skimage.morphology import erosion
  4146                                                       separated_markers = erosion(separated_markers, disk(erosion_disk)) #3.5
  4147                                                       separated_markers[data_2d_watershed[tt,:,:] == 0] = 0
  4148                                                       
  4149                                                       # add unique new markers if they are not too close to old objects
  4150                                                       from skimage.morphology import dilation, square, disk
  4151                                                       dilated_matrix = dilation(data_2d_watershed[tt-1,:,:].astype("int"), disk(2.5))
  4152                                                       markers_updated = (markers + np.max(separated_markers)).astype("int")
  4153                                                       markers_updated[markers_updated == np.max(separated_markers)] = 0
  4154                                                       markers_add = (markers_updated != 0) & (dilated_matrix == 0)
  4155                                                       
  4156                                                       separated_markers[markers_add] = markers_updated[markers_add]
  4157                                                       markers = separated_markers
  4158                                                       # break up elements that are no longer connected
  4159                                                       markers, _ = ndi.label(markers)
  4160                                               
  4161                                                       # make sure that spatially separate objects have unique labels
  4162                                                       # markers, _ = ndi.label(mask)
  4163                                                   data_2d_watershed[tt,:,:] = watershed(image = np.array(data[tt,:])*-1,  # watershedding field with maxima transformed to minima
  4164                                                                   markers = markers, # maximum points in 3D matrix
  4165                                                                   connectivity = np.ones((3, 3)), # connectivity
  4166                                                                   offset = (np.ones((2)) * 1).astype('int'), #4000/dx_m[dx]).astype('int'),
  4167                                                                   mask = image, # binary mask for areas to watershed on
  4168                                                                   compactness = 0) # high values --> more regular shaped watersheds
  4169                                               
  4170                                               if connectLon == 1:
  4171                                                   # Crop to the original size
  4172                                                   # start = extension_size
  4173                                                   # end = start + image.shape[axis]
  4174                                                   if extension_size != 0:
  4175                                                       data_2d_watershed = np.array(data_2d_watershed[:, :, extension_size:-extension_size])
  4176                                                   data_2d_watershed = ConnectLon_on_timestep(data_2d_watershed.astype("int"))
  4177                                           
  4178                                               ### CONNECT OBJECTS IN 3D BASED ON MAX OVERLAP
  4179                                               labels = np.array(data_2d_watershed).astype('int')
  4180                                               objects = connect_3d_objects(labels, 
  4181                                                                            int(mintime/dT), 
  4182                                                                            dT)
  4183                                               return objects

Total time: 0.885767 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: label_peaks_over_time_3d at line 4187

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4187                                           @profile
  4188                                           def label_peaks_over_time_3d(coords, max_dist=5):
  4189                                               """
  4190                                               coords: np.ndarray of shape (N_peaks, 3), each row is [t, y, x]
  4191                                               max_dist: maximum allowed distance to consider peaks as the same object (in grid units)
  4192                                               Returns: labels, np.ndarray of shape (N_peaks,), integer labels for each peak
  4193                                               """
  4194                                               # Split coords by timestep
  4195         2        308.9    154.4      0.0      timesteps = np.unique(coords[:, 0])
  4196         2         10.5      5.3      0.0      labels = np.zeros(coords.shape[0], dtype=int)
  4197         2          2.0      1.0      0.0      next_label = 1
  4198         2          2.2      1.1      0.0      prev_coords = None
  4199         2          2.3      1.1      0.0      prev_labels = None
  4200                                           
  4201        50         54.4      1.1      0.0      for t in timesteps:
  4202        48       1203.0     25.1      0.1          idx_t = np.where(coords[:, 0] == t)[0]
  4203        48        535.8     11.2      0.1          coords_t = coords[idx_t][:, 1:3]  # [y, x] only
  4204        48        119.1      2.5      0.0          labels_t = np.zeros(coords_t.shape[0], dtype=int)
  4205        48         49.2      1.0      0.0          if prev_coords is None or prev_coords.shape[0] == 0:
  4206                                                       # First timestep: assign new labels
  4207         2         21.3     10.6      0.0              labels_t[:] = np.arange(next_label, next_label + coords_t.shape[0])
  4208         2          3.4      1.7      0.0              next_label += coords_t.shape[0]
  4209                                                   else:
  4210                                                       # Build KDTree for previous peaks
  4211        46       5848.4    127.1      0.7              tree = cKDTree(prev_coords)
  4212     16577      13544.4      0.8      1.5              for i, peak in enumerate(coords_t):
  4213     16531     832339.6     50.4     94.0                  dist, idx = tree.query(peak, distance_upper_bound=max_dist)
  4214     16531      13716.8      0.8      1.5                  if dist < max_dist and idx < prev_coords.shape[0]:
  4215     12105      11713.1      1.0      1.3                      labels_t[i] = prev_labels[idx]
  4216                                                           else:
  4217      4426       3424.3      0.8      0.4                      labels_t[i] = next_label
  4218      4426       2652.3      0.6      0.3                      next_label += 1
  4219        48        117.7      2.5      0.0          labels[idx_t] = labels_t
  4220        48         51.4      1.1      0.0          prev_coords = coords_t
  4221        48         42.0      0.9      0.0          prev_labels = labels_t
  4222         2          4.5      2.2      0.0      return labels

Total time: 6.62168 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: watershed_3d_overlap at line 4266

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4266                                           @profile
  4267                                           def watershed_3d_overlap(data, # 3D matrix with data for watershedding [np.array]
  4268                                                                    object_threshold, # float to create binary object mast [float]
  4269                                                                    max_treshold, # value for identifying max. points for spreading [float]
  4270                                                                    min_dist, # minimum distance (in grid cells) between maximum points [int]
  4271                                                                    dT, # time interval in hours [int]
  4272                                                                    mintime = 24, # minimum time an object has to exist in dT [int]
  4273                                                                    connectLon = 0,  # do we have to track features over the date line?
  4274                                                                    extend_size_ratio = 0.25, _timer=None): # if connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs
  4275                                               
  4276                                               # from Tracking_Functions import ConnectLon_on_timestep
  4277                                               # with _timer("setup"):
  4278                                                   # Determine if we need to extend the data for date line crossing
  4279         2          3.7      1.9      0.0      if connectLon == 1:
  4280         2          1.8      0.9      0.0          axis = 2
  4281         2         12.6      6.3      0.0          extension_size = int(data.shape[2] * extend_size_ratio)
  4282         4     115459.6  28864.9      1.7          data = np.concatenate(
  4283         2         15.9      8.0      0.0                  [data[:, :, -extension_size:], data, data[:, :, :extension_size]], axis=axis
  4284                                                       )
  4285                                               
  4286                                               # Create binary mask for watershedding, all data that needs to be segmented is True
  4287         2      40521.0  20260.5      0.6      image = data >= object_threshold
  4288                                               
  4289                                               # with _timer("find peaks"):
  4290         2          6.1      3.1      0.0      coords_list = []
  4291                                           
  4292                                               # find peaks in each time slice and add time as an additional coordinate
  4293        50         87.2      1.7      0.0      for t in range(data.shape[0]):
  4294        96    1768085.6  18417.6     26.7          coords_t = peak_local_max(data[t], 
  4295        48         46.2      1.0      0.0                                  min_distance = min_dist,
  4296        48         29.2      0.6      0.0                                  threshold_abs = max_treshold,
  4297        48         58.4      1.2      0.0                                  labels = image[t],
  4298        48         26.7      0.6      0.0                                  exclude_border=True
  4299                                                                       )
  4300                                           
  4301        48       1947.3     40.6      0.0          coords_with_time = np.column_stack((np.full(coords_t.shape[0], t), coords_t))
  4302        48         73.8      1.5      0.0          coords_list.append(coords_with_time)
  4303                                           
  4304                                               # Combine all coordinates into a single array
  4305         2          4.1      2.1      0.0      if len(coords_list) > 0:
  4306         2        208.9    104.5      0.0          coords = np.vstack(coords_list)
  4307                                               else:
  4308                                                   coords = np.empty((0, 3), dtype=int)
  4309                                           
  4310                                               # with _timer("label peaks over time"):
  4311         2        502.7    251.4      0.0      mask = np.zeros(data.shape, dtype=bool)
  4312         2       7586.8   3793.4      0.1      mask[tuple(coords.T)] = True
  4313                                           
  4314                                               # label peaks over time to ensure temporal consistency
  4315         2     906838.2 453419.1     13.7      labels = label_peaks_over_time_3d(coords, max_dist=min_dist)
  4316         2         75.2     37.6      0.0      markers = np.zeros(data.shape, dtype=np.int16)
  4317         2      17738.8   8869.4      0.3      markers[tuple(coords.T)] = labels
  4318                                               
  4319                                               # with _timer("watershed"):
  4320                                                   # define connectivity for 3D watershedding and perform watershedding
  4321         2         78.8     39.4      0.0      conection = np.ones((3, 3, 3))
  4322         4    3654108.7 913527.2     55.2      watershed_results = watershed(image = np.array(data)*-1,  # watershedding field with maxima transformed to minima
  4323         2          5.9      3.0      0.0                      markers = markers, # maximum points in 3D matrix
  4324         2          2.7      1.4      0.0                      connectivity = conection, # connectivity
  4325         2        137.0     68.5      0.0                      offset = (np.ones((3)) * 1).astype('int'), #4000/dx_m[dx]).astype('int'),
  4326         2          2.7      1.3      0.0                      mask = image, # binary mask for areas to watershed on
  4327         2          2.2      1.1      0.0                      compactness = 0) # high values --> more regular shaped watersheds
  4328                                           
  4329                                               # correct objects on date line if needed
  4330         2          7.8      3.9      0.0      if connectLon == 1:
  4331         2          3.0      1.5      0.0          if extension_size != 0:
  4332         2      20962.3  10481.1      0.3              watershed_results = np.array(watershed_results[:, :, extension_size:-extension_size])
  4333         2      87029.0  43514.5      1.3          watershed_results = ConnectLon_on_timestep(watershed_results.astype("int"))
  4334                                           
  4335         2          6.7      3.4      0.0      return watershed_results

Total time: 19.5028 s
File: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py
Function: moaap at line 4782

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  4782                                           @profile
  4783                                           def moaap(
  4784                                               Lon,                           # 2D longitude grid centers
  4785                                               Lat,                           # 2D latitude grid spacing
  4786                                               Time,                          # datetime vector of data
  4787                                               dT,                            # integer - temporal frequency of data [hour]
  4788                                               Mask,                          # mask with dimensions [lat,lon] defining analysis region
  4789                                               *, 
  4790                                               config_file=None, 
  4791                                               **kw):
  4792                                               
  4793                                               """
  4794                                               Parameters
  4795                                               ----------
  4796                                               Lon : array_like
  4797                                                   2D array of longitude grid centers.
  4798                                               Lat : array_like
  4799                                                   2D array of latitude grid centers.
  4800                                               Time : array_like of datetime
  4801                                                   1D vector of datetimes for each time step.
  4802                                               dT : int
  4803                                                   Temporal frequency of the data in hours.
  4804                                               Mask : array_like
  4805                                                   2D mask defining the analysis region.
  4806                                           
  4807                                               Keyword Arguments
  4808                                               -----------------
  4809                                               v850 : array_like or None, default=None
  4810                                                   850hPa zonal wind speed (m/s).
  4811                                               u850 : array_like or None, default=None
  4812                                                   850hPa meridional wind speed (m/s).
  4813                                               t850 : array_like or None, default=None
  4814                                                   850hPa air temperature (K).
  4815                                               q850 : array_like or None, default=None
  4816                                                   850hPa mixing ratio (g/kg).
  4817                                               slp : array_like or None, default=None
  4818                                                   Sea level pressure (Pa).
  4819                                               ivte : array_like or None, default=None
  4820                                                   Zonal integrated vapor transport (kgms).
  4821                                               ivtn : array_like or None, default=None
  4822                                                   Meridional integrated vapor transport (kgms).
  4823                                               z500 : array_like or None, default=None
  4824                                                   Geopotential height at 500hPa (gpm).
  4825                                               v200 : array_like or None, default=None
  4826                                                   200hPa zonal wind speed (m/s).
  4827                                               u200 : array_like or None, default=None
  4828                                                   200hPa meridional wind speed (m/s).
  4829                                               pr : array_like or None, default=None
  4830                                                   Accumulated surface precipitation (mm per time step).
  4831                                               tb : array_like or None, default=None
  4832                                                   Brightness temperature (K).
  4833                                               DataName : str, default=''
  4834                                                   Name of the common grid.
  4835                                               OutputFolder : str, default=''
  4836                                                   Path to the output directory.
  4837                                           
  4838                                               #  Precipitation objects 
  4839                                               SmoothSigmaP : float, default=0
  4840                                                   Gaussian  for precipitation smoothing.
  4841                                               Pthreshold : float, default=2
  4842                                                   Precipitation threshold (mmh).
  4843                                               MinTimePR : int, default=4
  4844                                                   Minimum lifetime of precipitation features (h).
  4845                                               MinAreaPR : float, default=5000
  4846                                                   Minimum area of precipitation features (km).
  4847                                           
  4848                                               #  Moisture streams 
  4849                                               MinTimeMS : int, default=9
  4850                                                   Minimum lifetime of moisture stream features (h).
  4851                                               MinAreaMS : float, default=100000
  4852                                                   Minimum area of moisture stream features (km).
  4853                                               MinMSthreshold : float, default=0.11
  4854                                                   Detection threshold for moisture streams (gm/gs).
  4855                                           
  4856                                               #  Cyclones & anticyclones 
  4857                                               MinTimeCY : int, default=12
  4858                                                   Minimum lifetime of cyclones (h).
  4859                                               MaxPresAnCY : float, default=-8
  4860                                                   Pressure anomaly threshold for cyclones (hPa).
  4861                                               breakup_cy : str, default='watershed'
  4862                                                   Method for cyclone breakup.
  4863                                               MinTimeACY : int, default=12
  4864                                                   Minimum lifetime of anticyclones (h).
  4865                                               MinPresAnACY : float, default=6
  4866                                                   Pressure anomaly threshold for anticyclones (hPa).
  4867                                           
  4868                                               #  Frontal zones 
  4869                                               MinAreaFR : float, default=50000
  4870                                                   Minimum area of frontal zones (km).
  4871                                               front_treshold : float, default=1
  4872                                                   Threshold for masking frontal zones.
  4873                                           
  4874                                               #  Cloud tracking 
  4875                                               SmoothSigmaC : float, default=0
  4876                                                   Gaussian  for cloudshield smoothing.
  4877                                               Cthreshold : float, default=241
  4878                                                   Brightness temperature threshold for icecloud shields (K).
  4879                                               MinTimeC : int, default=4
  4880                                                   Minimum lifetime of icecloud shields (h).
  4881                                               MinAreaC : float, default=40000
  4882                                                   Minimum area of icecloud shields (km).
  4883                                           
  4884                                               #  Atmospheric rivers (AR) 
  4885                                               IVTtrheshold : float, default=500
  4886                                                   Integrated vapor transport threshold for AR detection (kgms).
  4887                                               MinTimeIVT : int, default=12
  4888                                                   Minimum lifetime of ARs (h).
  4889                                               breakup_ivt : str, default='watershed'
  4890                                                   Method for AR breakup.
  4891                                               AR_MinLen : float, default=2000
  4892                                                   Minimum length of an AR (km).
  4893                                               AR_Lat : float, default=20
  4894                                                   Minimum centroid latitude for ARs (degrees N).
  4895                                               AR_width_lenght_ratio : float, default=2
  4896                                                   Minimum lengthtowidth ratio for ARs.
  4897                                           
  4898                                               #  Tropical cyclone detection 
  4899                                               TC_Pmin : float, default=995
  4900                                                   Minimum central pressure for TC detection (hPa).
  4901                                               TC_lat_genesis : float, default=35
  4902                                                   Maximum latitude for TC genesis (degrees).
  4903                                               TC_lat_max : float, default=60
  4904                                                   Maximum latitude for TC existence (degrees).
  4905                                               TC_deltaT_core : float, default=0
  4906                                                   Minimum coretoenvironment temperature difference (K).
  4907                                               TC_T850min : float, default=285
  4908                                                   Minimum core temperature at 850hPa for TCs (K).
  4909                                           
  4910                                               #  Mesoscale convective systems (MCS) 
  4911                                               MCS_Minsize : float, default=5000
  4912                                                   Minimum precipitation area size for MCS (km).
  4913                                               MCS_minPR : float, default=15
  4914                                                   Precipitation threshold for MCS detection (mmh).
  4915                                               CL_MaxT : float, default=215
  4916                                                   Maximum brightness temperature in ice shield for MCS (K).
  4917                                               CL_Area : float, default=40000
  4918                                                   Minimum cloud area for MCS detection (km).
  4919                                               MCS_minTime : int, default=4
  4920                                                   Minimum lifetime of MCS (h).
  4921                                           
  4922                                               #  Jet streams & tropical waves 
  4923                                               js_min_anomaly : float, default=37
  4924                                                   Minimum jetstream anomaly (m/s).
  4925                                               MinTimeJS : int, default=24
  4926                                                   Minimum lifetime of jet streams (h).
  4927                                               breakup_jet : str, default='watershed'
  4928                                                   Method for jetstream breakup.
  4929                                               tropwave_minTime : int, default=48
  4930                                                   Minimum lifetime of tropical waves (h).
  4931                                               breakup_mcs : str, default='watershed'
  4932                                                   Method for MCS breakup.
  4933                                           
  4934                                               #  500hPa cyclones/anticyclones 
  4935                                               z500_low_anom : float, default=-80
  4936                                                   Minimum anomaly for 500hPa cyclones (m).
  4937                                               z500_high_anom : float, default=70
  4938                                                   Minimum anomaly for 500hPa anticyclones (m).
  4939                                               breakup_zcy : str, default='watershed'
  4940                                                   Method for 500hPa cyclone/anticyclone breakup.
  4941                                           
  4942                                               #  Equatorial waves 
  4943                                               er_th : float, default=0.05
  4944                                                   Threshold for equatorial Rossby waves.
  4945                                               mrg_th : float, default=0.05
  4946                                                   Threshold for mixed Rossbygravity waves.
  4947                                               igw_th : float, default=0.20
  4948                                                   Threshold for inertiagravity waves.
  4949                                               kel_th : float, default=0.10
  4950                                                   Threshold for Kelvin waves.
  4951                                               eig0_th : float, default=0.10
  4952                                                   Threshold for n1 inertiagravity waves.
  4953                                               breakup_tw : str, default='watershed'
  4954                                                   Method for equatorial wave breakup.
  4955                                           
  4956                                               Returns
  4957                                               -------
  4958                                               dict
  4959                                                   A dictionary containing detected features grouped by type
  4960                                                   (e.g., 'precip', 'moisture', 'cyclones', etc.).
  4961                                               """
  4962                                               
  4963         1          5.7      5.7      0.0      params = MOAAP_DEFAULTS.copy()
  4964                                               # ... load/merge config_file if given ...
  4965         1          2.4      2.4      0.0      params.update(kw)
  4966                                               # check if the input variables are np.arrays
  4967         1          1.3      1.3      0.0      required_keys = [
  4968                                                   "v850",  "u850",  "t850",  "q850",  "slp",
  4969                                                   "ivte",  "ivtn",  "z500",  "v200",  "u200",
  4970                                                   "pr",    "tb"
  4971                                               ]
  4972                                           
  4973        13         10.0      0.8      0.0      for key in required_keys:
  4974        12          8.5      0.7      0.0          if key in params:
  4975        12         10.4      0.9      0.0              if type(params[key]) is not type(None):
  4976         2          3.2      1.6      0.0                  if not isinstance(params[key], np.ndarray):
  4977                                                               # Display which variable is wrong, then stop
  4978                                                               raise TypeError(f"Parameter '{key}' must be a numpy.ndarray, got {type(params[key]).__name__}")
  4979                                           
  4980         1          1.3      1.3      0.0      v850 = params["v850"]                   # 850 hPa zonal wind speed [m/s]
  4981         1          1.1      1.1      0.0      u850 = params["u850"]                   # 850 hPa meridional wind speed [m/s]
  4982         1          1.1      1.1      0.0      t850 = params["t850"]                   # 850 hPa air temperature [K]
  4983         1          1.0      1.0      0.0      q850 = params["q850"]                   # 850 hPa mixing ratio [g/kg]
  4984         1          1.0      1.0      0.0      slp =  params["slp"]                    # sea level pressure [Pa]
  4985         1          1.1      1.1      0.0      ivte = params["ivte"]                   # zonal integrated vapor transport [kg m-1 s-1]
  4986         1          1.3      1.3      0.0      ivtn = params["ivtn"]                   # meridional integrated vapor transport [kg m-1 s-1]
  4987         1          1.4      1.4      0.0      z500 = params["z500"]                   # geopotential height [gpm]
  4988         1          1.1      1.1      0.0      v200 = params["v200"]                   # 200 hPa zonal wind speed [m/s]
  4989         1          1.1      1.1      0.0      u200 = params["u200"]                   # 200 hPa meridional wind speed [m/s]
  4990         1          1.4      1.4      0.0      pr   = params["pr"]                     # accumulated surface precipitation [mm/time]
  4991         1          1.4      1.4      0.0      tb   = params["tb"]                     # brightness temperature [K]
  4992                                                   
  4993                                           
  4994                                               # calculate grid spacing assuming a regular lat/lon grid
  4995         1     194467.3 194467.3      1.0      _,_,Area,Gridspacing = calc_grid_distance_area(Lon,Lat)
  4996         1        684.7    684.7      0.0      Area[Area < 0] = 0
  4997                                               
  4998         1          3.9      3.9      0.0      EarthCircum = 40075000 #[m]
  4999         1       4370.2   4370.2      0.0      Lat = np.array(Lat)
  5000         1       2386.1   2386.1      0.0      Lon = np.array(Lon)
  5001         1       2684.4   2684.4      0.0      dLat = np.copy(Lon); dLat[:] = EarthCircum/(360/(Lat[1,0]-Lat[0,0]))
  5002         1       2067.8   2067.8      0.0      dLon = np.copy(Lon)
  5003       722       1092.8      1.5      0.0      for la in range(Lat.shape[0]):
  5004       721       4106.3      5.7      0.0          dLon[la,:] = EarthCircum/(360/(Lat[1,0]-Lat[0,0]))*np.cos(np.deg2rad(Lat[la,0]))
  5005         1       2681.6   2681.6      0.0      dLat = np.abs(dLat)
  5006         1        896.3    896.3      0.0      dLon = np.abs(dLon)
  5007                                               
  5008         1        127.4    127.4      0.0      StartDay = Time[0]
  5009         1          5.7      5.7      0.0      SetupString = '_dt-'+str(dT)+'h_MOAAP-masks'
  5010         1          9.4      9.4      0.0      NCfile = params["OutputFolder"] + str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+params["DataName"]+'_ObjectMasks_'+SetupString+'.nc'
  5011         1        588.6    588.6      0.0      FrontMask = np.copy(Mask)
  5012         1          2.9      2.9      0.0      try:
  5013         1       3363.3   3363.3      0.0          FrontMask[np.abs(Lat) < 10] = 0
  5014                                               except:
  5015                                                   print('            latitude does not expand into the tropics')
  5016                                           
  5017                                               # connect over date line?
  5018         1          8.2      8.2      0.0      if (Lon[0,0] < -176) & (Lon[0,-1] > 176):
  5019         1          3.1      3.1      0.0          connectLon= 1
  5020                                               else:
  5021                                                   connectLon= 0
  5022                                           
  5023                                               ### print out which phenomenon can be investigated
  5024         1          2.7      2.7      0.0      if slp is not None:
  5025                                                   slp_test = 'yes'
  5026                                               else:
  5027         1          2.5      2.5      0.0          slp_test = 'no'
  5028         1          3.1      3.1      0.0      if (ivte is not None) & (ivtn is not None):
  5029                                                   ar_test = 'yes'
  5030                                               else:
  5031         1          2.3      2.3      0.0          ar_test = 'no'
  5032         1          4.0      4.0      0.0      if (v850 is not None) & (u850 is not None) & (t850 is not None):
  5033                                                   front_test = 'yes'
  5034                                               else:
  5035         1          6.3      6.3      0.0          front_test = 'no'
  5036         3          8.9      3.0      0.0      if (slp is not None) & (tb is not None) \
  5037         2          5.2      2.6      0.0         & (t850 is not None) & (pr is not None):
  5038                                                   tc_test = 'yes'
  5039                                               else:
  5040         1          2.6      2.6      0.0          tc_test = 'no'
  5041         1          2.9      2.9      0.0      if z500 is not None:
  5042                                                   z500_test = 'yes'
  5043                                               else:
  5044         1          2.6      2.6      0.0          z500_test = 'no'
  5045         2          5.8      2.9      0.0      if (z500 is not None) & (front_test == 'yes') & \
  5046         1          2.6      2.6      0.0         (u200 is not None):
  5047                                                   col_test = 'yes'
  5048                                               else:
  5049         1          3.1      3.1      0.0          col_test = 'no'
  5050         1          3.2      3.2      0.0      if (v200 is not None) & (u200 is not None):
  5051                                                   jet_test = 'yes'
  5052                                               else:
  5053         1          3.0      3.0      0.0          jet_test = 'no'
  5054         1          3.2      3.2      0.0      if (pr is not None) & (tb is not None):
  5055         1          3.1      3.1      0.0          mcs_tb_test = 'yes'
  5056                                               else:
  5057                                                   mcs_tb_test = 'no'
  5058         1          3.1      3.1      0.0      if (pr is not None) & (tb is not None):
  5059         1          3.5      3.5      0.0          cloud_test = 'yes'
  5060                                               else:
  5061                                                   cloud_test = 'no'
  5062         2          6.7      3.3      0.0      if (q850 is not None) & (v850 is not None) & \
  5063         1          3.1      3.1      0.0         (u850 is not None):
  5064                                                   ms_test = 'yes'
  5065                                               else:
  5066         1          3.7      3.7      0.0          ms_test = 'no'
  5067         1          3.3      3.3      0.0      if (pr is not None):
  5068         1          3.4      3.4      0.0          ew_test = 'yes'
  5069                                               else:
  5070                                                   ew_test = 'no'
  5071                                           
  5072         1          3.4      3.4      0.0      """
  5073                                               jet_test =  'no'
  5074                                               slp_test = 'yes'
  5075                                               z500_test =  'no'
  5076                                               col_test = 'no' 
  5077                                               ar_test =  'no'
  5078                                               ms_test =  'no'
  5079                                               front_test =  'no'
  5080                                               tc_test = 'yes'
  5081                                               mcs_tb_test =  'no'
  5082                                               cloud_test =  'no'
  5083                                               ew_test =  'no'
  5084                                               """
  5085         1          3.3      3.3      0.0      ew_test =  'no'
  5086                                               
  5087         1         10.4     10.4      0.0      print(' ')
  5088         1          4.8      4.8      0.0      print('The provided variables allow tracking the following phenomena')
  5089         1          3.9      3.9      0.0      print(' ')
  5090         1          4.2      4.2      0.0      print('|  phenomenon  | tracking |')
  5091         1          3.9      3.9      0.0      print('---------------------------')
  5092         1          4.3      4.3      0.0      print('   Jetstream   |   ' + jet_test)
  5093         1          4.4      4.4      0.0      print('   PSL CY/ACY  |   ' + slp_test)
  5094         1          3.7      3.7      0.0      print('   Z500 CY/ACY |   ' + z500_test)
  5095         1          4.1      4.1      0.0      print('   COLs        |   ' + col_test)
  5096         1          3.8      3.8      0.0      print('   IVT ARs     |   ' + ar_test)
  5097         1          4.4      4.4      0.0      print('   MS ARs      |   ' + ms_test)
  5098         1          4.0      4.0      0.0      print('   Fronts      |   ' + front_test)
  5099         1          4.2      4.2      0.0      print('   TCs         |   ' + tc_test)
  5100         1          3.9      3.9      0.0      print('   MCSs        |   ' + mcs_tb_test)
  5101         1          4.0      4.0      0.0      print('   clouds      |   ' + cloud_test)
  5102         1          4.2      4.2      0.0      print('   Equ. Waves  |   ' + ew_test)
  5103         1          4.8      4.8      0.0      print('---------------------------')
  5104         1          3.9      3.9      0.0      print(' ')
  5105                                           
  5106                                               
  5107         1          6.2      6.2      0.0      import time
  5108                                               
  5109                                               # Mask data outside of Focus domain
  5110         1          3.7      3.7      0.0      try:
  5111         1        503.3    503.3      0.0          v850[:,Mask == 0] = np.nan
  5112         1         30.4     30.4      0.0      except:
  5113         1         15.6     15.6      0.0          pass
  5114         1          4.4      4.4      0.0      try:
  5115         1        479.3    479.3      0.0          u850[:,Mask == 0] = np.nan
  5116         1         25.0     25.0      0.0      except:
  5117         1         13.5     13.5      0.0          pass
  5118         1          4.5      4.5      0.0      try:
  5119         1        322.1    322.1      0.0          t850[:,Mask == 0] = np.nan
  5120         1         21.7     21.7      0.0      except:
  5121         1         13.0     13.0      0.0          pass
  5122         1          4.0      4.0      0.0      try:
  5123         1        286.3    286.3      0.0          q850[:,Mask == 0] = np.nan
  5124         1         20.4     20.4      0.0      except:
  5125         1         12.8     12.8      0.0          pass
  5126         1          3.8      3.8      0.0      try:
  5127         1        304.2    304.2      0.0          slp[:,Mask == 0]  = np.nan
  5128         1         12.3     12.3      0.0      except:
  5129         1          2.9      2.9      0.0          pass
  5130         1          4.4      4.4      0.0      try:
  5131         1        326.7    326.7      0.0          ivte[:,Mask == 0] = np.nan
  5132         1          0.9      0.9      0.0      except:
  5133         1          2.9      2.9      0.0          pass
  5134         1          4.5      4.5      0.0      try:
  5135         1        290.8    290.8      0.0          ivtn[:,Mask == 0] = np.nan
  5136         1          0.9      0.9      0.0      except:
  5137         1          2.8      2.8      0.0          pass
  5138         1          4.2      4.2      0.0      try:
  5139         1        277.3    277.3      0.0          z500[:,Mask == 0] = np.nan
  5140         1          0.9      0.9      0.0      except:
  5141         1          2.8      2.8      0.0          pass
  5142         1          4.4      4.4      0.0      try:
  5143         1        279.0    279.0      0.0          v200[:,Mask == 0] = np.nan
  5144         1          0.7      0.7      0.0      except:
  5145         1          2.6      2.6      0.0          pass
  5146         1          4.5      4.5      0.0      try:
  5147         1        280.4    280.4      0.0          u200[:,Mask == 0] = np.nan
  5148         1          0.7      0.7      0.0      except:
  5149         1          2.8      2.8      0.0          pass
  5150         1          4.3      4.3      0.0      try:
  5151         1        630.6    630.6      0.0          pr[:,Mask == 0]   = np.nan
  5152                                               except:
  5153                                                   pass
  5154         1          4.8      4.8      0.0      try:
  5155         1        484.8    484.8      0.0          tb[:,Mask == 0]   = np.nan
  5156                                               except:
  5157                                                   pass
  5158                                           
  5159         1          6.1      6.1      0.0      if jet_test == 'yes':
  5160                                                   print('======> track jetstream')
  5161                                                   start = time.perf_counter()
  5162                                                   uv200 = (u200 ** 2 + v200 ** 2) ** 0.5
  5163                                           
  5164                                                   jet_objects, object_split = jetstream_tracking(uv200,
  5165                                                                                 params["js_min_anomaly"],
  5166                                                                                 params["MinTimeJS"],
  5167                                                                                 dT,
  5168                                                                                 Gridspacing,
  5169                                                                                 connectLon,
  5170                                                                                 breakup = params["breakup_jet"])
  5171                                                   jet_objects_characteristics = calc_object_characteristics(jet_objects, # feature object file
  5172                                                                                uv200,         # original file used for feature detection
  5173                                                                                params["OutputFolder"]+'jet_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5174                                                                                Time,            # timesteps of the data
  5175                                                                                Lat,             # 2D latidudes
  5176                                                                                Lon,             # 2D Longitudes
  5177                                                                                Gridspacing,
  5178                                                                                Area,
  5179                                                                                min_tsteps=int(params["MinTimeJS"]/dT),
  5180                                                                                split_merge = object_split)
  5181                                                   
  5182                                                   end = time.perf_counter()
  5183                                                   timer(start, end)
  5184                                                   
  5185                                               
  5186         1          6.6      6.6      0.0      if ew_test == 'yes':
  5187                                                   print('======> track tropical waves')
  5188                                                   start = time.perf_counter()
  5189                                                   mrg_objects, igw_objects, kelvin_objects, eig0_objects, er_objects = track_tropwaves_tb(
  5190                                                                   tb,
  5191                                                                   Lat,
  5192                                                                   connectLon,
  5193                                                                   dT,
  5194                                                                  Gridspacing,
  5195                                                                  er_th = params["er_th"],  # threshold for Rossby Waves
  5196                                                                  mrg_th = params["mrg_th"], # threshold for mixed Rossby Gravity Waves
  5197                                                                  igw_th = params["igw_th"],  # threshold for inertia gravity waves
  5198                                                                  kel_th = params["kel_th"],  # threshold for Kelvin waves
  5199                                                                  eig0_th = params["eig0_th"], # threshold for n>=1 Inertio Gravirt Wave
  5200                                                                  breakup = params["breakup_tw"]
  5201                                                                   )
  5202                                                   end = time.perf_counter()
  5203                                                   timer(start, end)
  5204                                           
  5205                                                   gr_mrg = calc_object_characteristics(mrg_objects, # feature object file
  5206                                                                            pr,         # original file used for feature detection
  5207                                                                            params["OutputFolder"]+'MRG_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,        # output file name and locaiton
  5208                                                                            Time,            # timesteps of the data
  5209                                                                            Lat,             # 2D latidudes
  5210                                                                            Lon,             # 2D Longitudes
  5211                                                                            Gridspacing,
  5212                                                                            Area,
  5213                                                                            min_tsteps=int(params["tropwave_minTime"]/dT))      # minimum livetime in hours
  5214                                                   
  5215                                                   gr_igw = calc_object_characteristics(igw_objects, # feature object file
  5216                                                                            pr,         # original file used for feature detection
  5217                                                                            params["OutputFolder"]+'IGW_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,        # output file name and locaiton
  5218                                                                            Time,            # timesteps of the data
  5219                                                                            Lat,             # 2D latidudes
  5220                                                                            Lon,             # 2D Longitudes
  5221                                                                            Gridspacing,
  5222                                                                            Area,
  5223                                                                            min_tsteps=int(48/dT))      # minimum livetime in hours
  5224                                                   
  5225                                                   gr_kelvin = calc_object_characteristics(kelvin_objects, # feature object file
  5226                                                                            pr,         # original file used for feature detection
  5227                                                                            params["OutputFolder"]+'Kelvin_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,        # output file name and locaiton
  5228                                                                            Time,            # timesteps of the data
  5229                                                                            Lat,             # 2D latidudes
  5230                                                                            Lon,             # 2D Longitudes
  5231                                                                            Gridspacing,
  5232                                                                            Area,
  5233                                                                            min_tsteps=int(48/dT))      # minimum livetime in hours
  5234                                                   
  5235                                                   gr_eig0 = calc_object_characteristics(eig0_objects, # feature object file
  5236                                                                            pr,         # original file used for feature detection
  5237                                                                            params["OutputFolder"]+'Eig0_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,        # output file name and locaiton
  5238                                                                            Time,            # timesteps of the data
  5239                                                                            Lat,             # 2D latidudes
  5240                                                                            Lon,             # 2D Longitudes
  5241                                                                            Gridspacing,
  5242                                                                            Area,
  5243                                                                            min_tsteps=int(48/dT))      # minimum livetime in hours
  5244                                                   
  5245                                                   gr_er = calc_object_characteristics(er_objects, # feature object file
  5246                                                                            pr,         # original file used for feature detection
  5247                                                                            params["OutputFolder"]+'ER_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,        # output file name and locaiton
  5248                                                                            Time,            # timesteps of the data
  5249                                                                            Lat,             # 2D latidudes
  5250                                                                            Lon,             # 2D Longitudes
  5251                                                                            Gridspacing,
  5252                                                                            Area,
  5253                                                                            min_tsteps=int(48/dT))      # minimum livetime in hours
  5254                                                   
  5255                                                   
  5256         1          7.6      7.6      0.0      if ms_test == 'yes':
  5257                                                   print('======> track moisture streams and atmospheric rivers (ARs)')
  5258                                                   start = time.perf_counter()
  5259                                                   VapTrans = ((u850 * q850)**2 + 
  5260                                                               (v850 * q850)**2)**(1/2)
  5261                                           
  5262                                                   MS_objects = ar_850hpa_tracking(
  5263                                                                                   VapTrans,
  5264                                                                                   params["MinMSthreshold"],
  5265                                                                                   params["MinTimeMS"],
  5266                                                                                   params["MinAreaMS"],
  5267                                                                                   Area,
  5268                                                                                   dT,
  5269                                                                                   connectLon,
  5270                                                                                   Gridspacing,
  5271                                                                                   breakup = params["breakup_ivt"])
  5272                                                   
  5273                                                   grMSs = calc_object_characteristics(MS_objects, # feature object file
  5274                                                                            VapTrans,         # original file used for feature detection
  5275                                                                            params["OutputFolder"]+'MS850_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,        # output file name and locaiton
  5276                                                                            Time,            # timesteps of the data
  5277                                                                            Lat,             # 2D latidudes
  5278                                                                            Lon,             # 2D Longitudes
  5279                                                                            Gridspacing,
  5280                                                                            Area,
  5281                                                                            min_tsteps=int(params["MinTimeMS"]/dT))      # minimum livetime in hours
  5282                                                   
  5283                                                   end = time.perf_counter()
  5284                                                   timer(start, end)
  5285                                                   
  5286                                               
  5287         1          8.1      8.1      0.0      if ar_test == 'yes':
  5288                                                   print('======> track IVT streams and atmospheric rivers (ARs)')
  5289                                                   start = time.perf_counter()
  5290                                                   IVT = (ivte ** 2 + ivtn ** 2) ** 0.5
  5291                                           
  5292                                                   IVT_objects = ar_ivt_tracking(IVT,
  5293                                                                               params["IVTtrheshold"],
  5294                                                                               params["MinTimeIVT"],
  5295                                                                               dT,
  5296                                                                               Gridspacing,
  5297                                                                               connectLon,
  5298                                                                               breakup = params["breakup_ivt"])
  5299                                           
  5300                                                   grIVTs = calc_object_characteristics(IVT_objects, # feature object file
  5301                                                                                IVT,         # original file used for feature detection
  5302                                                                                params["OutputFolder"]+'IVT_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5303                                                                                Time,            # timesteps of the data
  5304                                                                                Lat,             # 2D latidudes
  5305                                                                                Lon,             # 2D Longitudes
  5306                                                                                Gridspacing,
  5307                                                                                Area,
  5308                                                                                min_tsteps=int(params["MinTimeIVT"]/dT))      # minimum livetime in hours
  5309                                                   
  5310                                                   print('        check if MSs quallify as ARs')
  5311                                                   AR_obj = ar_check(IVT_objects,
  5312                                                                    params["AR_Lat"],
  5313                                                                    params["AR_width_lenght_ratio"],
  5314                                                                    params["AR_MinLen"],
  5315                                                                    Lon,
  5316                                                                    Lat)
  5317                                               
  5318                                                   grACs = calc_object_characteristics(AR_obj, # feature object file
  5319                                                                    IVT,         # original file used for feature detection
  5320                                                                    params["OutputFolder"]+'ARs_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5321                                                                    Time,            # timesteps of the data
  5322                                                                    Lat,             # 2D latidudes
  5323                                                                    Lon,             # 2D Longitudes
  5324                                                                    Gridspacing,
  5325                                                                    Area)
  5326                                                   
  5327                                                   end = time.perf_counter()
  5328                                                   timer(start, end)
  5329                                               
  5330         1          9.0      9.0      0.0      if front_test == 'yes':
  5331                                                   print('======> identify frontal zones')
  5332                                                   start = time.perf_counter()
  5333                                                   
  5334                                                   # -------
  5335                                                   dx = dLon
  5336                                                   dy = dLat
  5337                                                   du = np.gradient( np.array(u850) )
  5338                                                   dv = np.gradient( np.array(v850) )
  5339                                                   PV = np.abs( dv[-1]/dx[None,:] - du[-2]/dy[None,:] )
  5340                                                   vgrad = np.gradient(np.array(t850), axis=(1,2))
  5341                                                   Tgrad = np.sqrt(vgrad[0]**2 + vgrad[1]**2)
  5342                                           
  5343                                                   Fstar = PV * Tgrad
  5344                                           
  5345                                                   Tgrad_zero = 0.45 #*100/(np.mean([dLon,dLat], axis=0)/1000.)  # 0.45 K/(100 km)
  5346                                                   import metpy.calc as calc
  5347                                                   from metpy.units import units
  5348                                                   CoriolisPar = np.array(calc.coriolis_parameter(np.deg2rad(Lat)))
  5349                                                   Frontal_Diagnostic = np.array(Fstar/(CoriolisPar * Tgrad_zero))
  5350                                                   
  5351                                                   FrontMask = np.copy(Mask)
  5352                                                   FrontMask[np.abs(Lat) < 10] = 0
  5353                                                   
  5354                                                   Frontal_Diagnostic = np.abs(Frontal_Diagnostic)
  5355                                                   Frontal_Diagnostic[:,FrontMask == 0] = 0
  5356                                                   # -------
  5357                                                   
  5358                                                   
  5359                                                   FR_objects = frontal_identification(Frontal_Diagnostic,
  5360                                                                         params["front_treshold"],
  5361                                                                         params["MinAreaFR"],
  5362                                                                         Area)
  5363                                                   
  5364                                                   end = time.perf_counter()
  5365                                                   timer(start, end)
  5366                                                   
  5367         1          9.9      9.9      0.0      if slp_test == 'yes':
  5368                                                   print('======> track cyclones from PSL')
  5369                                                   start = time.perf_counter()
  5370                                                   
  5371                                                   CY_objects, ACY_objects= cy_acy_psl_tracking(
  5372                                                                                               slp,
  5373                                                                                               params["MaxPresAnCY"],
  5374                                                                                               params["MinTimeCY"],
  5375                                                                                               params["MinPresAnACY"],
  5376                                                                                               params["MinTimeACY"],
  5377                                                                                               dT,
  5378                                                                                               Gridspacing,
  5379                                                                                               connectLon,
  5380                                                                                               breakup = params["breakup_cy"],
  5381                                                                                               )
  5382                                           
  5383                                                   grCyclonesPT = calc_object_characteristics(CY_objects, # feature object file
  5384                                                                                    slp,         # original file used for feature detection
  5385                                                                                    params["OutputFolder"]+'CY_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5386                                                                                    Time,            # timesteps of the data
  5387                                                                                    Lat,             # 2D latidudes
  5388                                                                                    Lon,             # 2D Longitudes
  5389                                                                                    Gridspacing,
  5390                                                                                    Area,
  5391                                                                                    min_tsteps=int(params["MinTimeCY"]/dT)) 
  5392                                           
  5393                                                   grACyclonesPT = calc_object_characteristics(ACY_objects, # feature object file
  5394                                                                                    slp,         # original file used for feature detection
  5395                                                                                    params["OutputFolder"]+'ACY_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5396                                                                                    Time,            # timesteps of the data
  5397                                                                                    Lat,             # 2D latidudes
  5398                                                                                    Lon,             # 2D Longitudes
  5399                                                                                    Gridspacing,
  5400                                                                                    Area,
  5401                                                                                    min_tsteps=int(params["MinTimeCY"]/dT)) 
  5402                                           
  5403                                                   end = time.perf_counter()
  5404                                                   timer(start, end)
  5405                                           
  5406         1         11.2     11.2      0.0      if z500_test == 'yes':
  5407                                                   print('======> track cyclones from Z500')
  5408                                                   start = time.perf_counter()
  5409                                                   cy_z500_objects, acy_z500_objects = cy_acy_z500_tracking(
  5410                                                                                       z500,
  5411                                                                                       params["MinTimeCY"],
  5412                                                                                       dT,
  5413                                                                                       Gridspacing,
  5414                                                                                       connectLon,
  5415                                                                                       z500_low_anom = params["z500_low_anom"],
  5416                                                                                       z500_high_anom = params["z500_high_anom"],
  5417                                                                                       breakup = params["breakup_zcy"],
  5418                                                                                       )
  5419                                                   
  5420                                                   cy_z500_objects_characteristics = calc_object_characteristics(cy_z500_objects, # feature object file
  5421                                                                                z500,         # original file used for feature detection
  5422                                                                                params["OutputFolder"]+'CY-z500_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5423                                                                                Time,            # timesteps of the data
  5424                                                                                Lat,             # 2D latidudes
  5425                                                                                Lon,             # 2D Longitudes
  5426                                                                                Gridspacing,
  5427                                                                                Area,
  5428                                                                                min_tsteps=int(params["MinTimeCY"]/dT))
  5429                                                   
  5430                                                   acy_z500_objects_characteristics = calc_object_characteristics(acy_z500_objects, # feature object file
  5431                                                                            z500,         # original file used for feature detection
  5432                                                                            params["OutputFolder"]+'ACY-z500_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5433                                                                            Time,            # timesteps of the data
  5434                                                                            Lat,             # 2D latidudes
  5435                                                                            Lon,             # 2D Longitudes
  5436                                                                            Gridspacing,
  5437                                                                            Area,
  5438                                                                            min_tsteps=int(params["MinTimeCY"]/dT)) 
  5439                                                   
  5440                                                   if col_test == 'yes':
  5441                                                       print('    Check if cyclones qualify as Cut Off Low (COL)')
  5442                                                       col_obj = col_identification(cy_z500_objects,
  5443                                                                              z500,
  5444                                                                              u200,
  5445                                                                              Frontal_Diagnostic,
  5446                                                                              params["MinTimeC"],
  5447                                                                              dx,
  5448                                                                              dy,
  5449                                                                              Lon,
  5450                                                                              Lat)
  5451                                           
  5452                                                       col_stats = calc_object_characteristics(col_obj, # feature object file
  5453                                                                        z500*9.81,            # original file used for feature detection
  5454                                                                        params["OutputFolder"]+'COL_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5455                                                                        Time,            # timesteps of the data
  5456                                                                        Lat,             # 2D latidudes
  5457                                                                        Lon,             # 2D Longitudes
  5458                                                                        Gridspacing,
  5459                                                                        Area,
  5460                                                                        min_tsteps=1)      # minimum livetime in hours
  5461                                           
  5462                                                   end = time.perf_counter()
  5463                                                   timer(start, end)
  5464                                           
  5465                                           
  5466         1         11.1     11.1      0.0      if mcs_tb_test == 'yes':
  5467         1         15.6     15.6      0.0          print("======> 'check if Tb objects qualify as MCS (or selected storm type)")
  5468         1         13.4     13.4      0.0          start = time.perf_counter()
  5469         2    5711500.8 2.86e+06     29.3          MCS_objects_Tb, C_objects = mcs_tb_tracking(tb,
  5470         1         16.4     16.4      0.0                              pr,
  5471         1         14.5     14.5      0.0                              params["SmoothSigmaC"],
  5472         1         13.8     13.8      0.0                              params["Pthreshold"],
  5473         1         13.7     13.7      0.0                              params["CL_Area"],
  5474         1         14.0     14.0      0.0                              params["CL_MaxT"],
  5475         1         13.7     13.7      0.0                              params["Cthreshold"],
  5476         1         14.1     14.1      0.0                              params["MinAreaC"],
  5477         1         14.3     14.3      0.0                              params["MinTimeC"],
  5478         1         14.0     14.0      0.0                              params["MCS_minPR"],
  5479         1         13.7     13.7      0.0                              params["MCS_minTime"],
  5480         1         14.0     14.0      0.0                              params["MCS_Minsize"],
  5481         1         13.9     13.9      0.0                              dT,
  5482         1         14.1     14.1      0.0                              Area,
  5483         1         13.5     13.5      0.0                              connectLon,
  5484         1         13.5     13.5      0.0                              Gridspacing,                 
  5485         1         13.8     13.8      0.0                              breakup=params["breakup_mcs"],
  5486                                                                      )
  5487                                                   
  5488         2    3706628.8 1.85e+06     19.0          grCs = calc_object_characteristics(C_objects, # feature object file
  5489         1         13.6     13.6      0.0                               tb,         # original file used for feature detection
  5490         1         25.7     25.7      0.0                               params["OutputFolder"]+'Clouds_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5491         1         13.2     13.2      0.0                               Time,            # timesteps of the data
  5492         1         13.3     13.3      0.0                               Lat,             # 2D latidudes
  5493         1         13.2     13.2      0.0                               Lon,             # 2D Longitudes
  5494         1         13.0     13.0      0.0                               Gridspacing,
  5495         1         13.2     13.2      0.0                               Area,
  5496         1         14.8     14.8      0.0                               min_tsteps=int(params["MinTimeC"]/dT))      # minimum livetime in hours
  5497                                                   
  5498         2     397691.1 198845.5      2.0          grMCSs_Tb = calc_object_characteristics(
  5499         1         14.0     14.0      0.0              MCS_objects_Tb,  # feature object file
  5500         1         13.1     13.1      0.0              pr,  # original file used for feature detection
  5501         1         22.4     22.4      0.0              params["OutputFolder"]+'MCSs_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5502         1         12.9     12.9      0.0              Time,            # timesteps of the data
  5503         1         13.2     13.2      0.0              Lat,             # 2D latidudes
  5504         1         12.8     12.8      0.0              Lon,             # 2D Longitudes
  5505         1         12.4     12.4      0.0              Gridspacing,
  5506         1         12.5     12.5      0.0              Area)
  5507                                                   
  5508         1         19.0     19.0      0.0          end = time.perf_counter()
  5509         1         80.1     80.1      0.0          timer(start, end)
  5510                                           
  5511                                               
  5512         1         15.4     15.4      0.0      if cloud_test == "yes":
  5513         1         15.3     15.3      0.0          print("======> 'track high clouds in Tb field by excluding MCS objects")
  5514         1         14.0     14.0      0.0          start = time.perf_counter()
  5515         1      35802.9  35802.9      0.2          tb_no_mcs = tb.copy()
  5516         1      39826.3  39826.3      0.2          tb_no_mcs[MCS_objects_Tb > 0] = 330 # remove MCSs from cloud field
  5517                                                   
  5518         2    3149587.7 1.57e+06     16.1          cloud_objects = cloud_tracking(
  5519         1         14.3     14.3      0.0                          tb_no_mcs,
  5520         1         13.5     13.5      0.0                          pr,
  5521         1         12.5     12.5      0.0                          connectLon,
  5522         1         12.0     12.0      0.0                          Gridspacing,
  5523         1         11.6     11.6      0.0                          dT,
  5524         1         13.5     13.5      0.0                          tb_threshold = params["Cthreshold"],
  5525         1         12.7     12.7      0.0                          tb_overshoot = params["cloud_overshoot"],
  5526         1         11.9     11.9      0.0                          erosion_disk = 1.5,
  5527         1         11.4     11.4      0.0                          min_dist = 8
  5528                                                                   )
  5529                                           
  5530         2    1247603.1 623801.5      6.4          grclouds_Tb = calc_object_characteristics(
  5531         1         12.8     12.8      0.0              cloud_objects,  # feature object file
  5532         1         12.2     12.2      0.0              pr,  # original file used for feature detection
  5533         1         20.8     20.8      0.0              params["OutputFolder"]+'non-MCS-clouds_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5534         1         12.3     12.3      0.0              Time,            # timesteps of the data
  5535         1         11.4     11.4      0.0              Lat,             # 2D latidudes
  5536         1         11.4     11.4      0.0              Lon,             # 2D Longitudes
  5537         1         11.4     11.4      0.0              Gridspacing,
  5538         1         11.3     11.3      0.0              Area)
  5539                                                   
  5540         1         17.6     17.6      0.0          end = time.perf_counter()
  5541         1         43.3     43.3      0.0          timer(start, end)
  5542                                                   
  5543         1         15.5     15.5      0.0      if tc_test == 'yes':
  5544                                                   print('======> Check if cyclones qualify as TCs')
  5545                                                   start = time.perf_counter()
  5546                                           
  5547                                                   TC_obj, TC_Tracks = tc_tracking(CY_objects,
  5548                                                                                   slp,
  5549                                                                   t850,
  5550                                                                   tb,
  5551                                                                   np.sqrt(u850**2 + v850**2),
  5552                                                                   np.sqrt(u200**2 + v200**2),
  5553                                                                   Lon,
  5554                                                                   Lat,
  5555                                                                   params["TC_lat_genesis"],
  5556                                                                   params["TC_T850min"]
  5557                                                                  )
  5558                                                   """
  5559                                                   TC_obj, TC_Tracks = tc_tracking(CY_objects,
  5560                                                                   t850,
  5561                                                                   slp,
  5562                                                                   tb,
  5563                                                                   C_objects,
  5564                                                                   Lon,
  5565                                                                   Lat,
  5566                                                                   params["TC_lat_genesis"],
  5567                                                                   params["TC_deltaT_core"],
  5568                                                                   params["TC_T850min"],
  5569                                                                   params["TC_Pmin"],
  5570                                                                   params["TC_lat_max"],
  5571                                                                  )
  5572                                                   """
  5573                                           
  5574                                                   
  5575                                                   grTCs = calc_object_characteristics(TC_obj, # feature object file
  5576                                                                        slp*100.,         # original file used for feature detection
  5577                                                                        params["OutputFolder"]+'TC_'+str(StartDay.year)+str(StartDay.month).zfill(2)+'_'+SetupString,
  5578                                                                        Time,            # timesteps of the data
  5579                                                                        Lat,             # 2D latidudes
  5580                                                                        Lon,             # 2D Longitudes
  5581                                                                        Gridspacing,
  5582                                                                        Area,
  5583                                                                        min_tsteps=int(params["MinTimeC"]/dT))      # minimum livetime in hours
  5584                                                   ### SAVE THE TC TRACKS TO PICKL FILE
  5585                                                   a_file = open(params["OutputFolder"]+str(Time[0].year)+str(Time[0].month).zfill(2)+'_TCs_tracks.pkl', "wb")
  5586                                                   pickle.dump(TC_Tracks, a_file)
  5587                                                   a_file.close()
  5588                                                   
  5589                                                   end = time.perf_counter()
  5590                                                   timer(start, end)  
  5591                                                   
  5592                                               
  5593                                           
  5594                                           
  5595         1         14.9     14.9      0.0      print(' ')
  5596         1         14.3     14.3      0.0      print('Save the object masks into a joint netCDF')
  5597         1         14.0     14.0      0.0      start = time.perf_counter()
  5598                                               # ============================
  5599                                               # Write NetCDF
  5600         1        856.7    856.7      0.0      iTime = np.array((Time - Time[0]).total_seconds()).astype('int')
  5601                                           
  5602         1      10700.7  10700.7      0.1      dataset = Dataset(NCfile,'w',format='NETCDF4_CLASSIC')
  5603         1        256.8    256.8      0.0      yc = dataset.createDimension('yc', Lat.shape[0])
  5604         1         87.3     87.3      0.0      xc = dataset.createDimension('xc', Lat.shape[1])
  5605         1        104.1    104.1      0.0      time = dataset.createDimension('time', None)
  5606                                           
  5607         1        316.9    316.9      0.0      times = dataset.createVariable('time', np.float64, ('time',))
  5608         1        291.1    291.1      0.0      lat = dataset.createVariable('lat', np.float32, ('yc','xc',))
  5609         1        325.7    325.7      0.0      lon = dataset.createVariable('lon', np.float32, ('yc','xc',))
  5610         1         17.0     17.0      0.0      if mcs_tb_test == 'yes':
  5611         1        315.5    315.5      0.0          PR_real = dataset.createVariable('PR', np.float32,('time','yc','xc'),zlib=True)
  5612                                                   # PR_obj = dataset.createVariable('PR_Objects', np.float32,('time','yc','xc'),zlib=True)
  5613                                                   # MCSs = dataset.createVariable('MCS_Objects', np.float32,('time','yc','xc'),zlib=True)
  5614         1        293.3    293.3      0.0          MCSs_Tb = dataset.createVariable('MCS_Tb_Objects', np.float32,('time','yc','xc'),zlib=True)
  5615         1        271.2    271.2      0.0          Cloud_real = dataset.createVariable('BT', np.float32,('time','yc','xc'),zlib=True)
  5616                                                   # Cloud_obj = dataset.createVariable('BT_Objects', np.float32,('time','yc','xc'),zlib=True)
  5617         1         14.8     14.8      0.0      if cloud_test == "yes":
  5618         1        342.2    342.2      0.0          non_mcs_cloud_obj = dataset.createVariable('non_mcs_cloud_Objects', np.float32,('time','yc','xc'),zlib=True)
  5619         1         15.4     15.4      0.0      if front_test == 'yes':
  5620                                                   FR_real = dataset.createVariable('FR', np.float32,('time','yc','xc'),zlib=True)
  5621                                                   FR_obj = dataset.createVariable('FR_Objects', np.float32,('time','yc','xc'),zlib=True)
  5622                                                   T_real = dataset.createVariable('T850', np.float32,('time','yc','xc'),zlib=True)
  5623         1         14.5     14.5      0.0      if slp_test == 'yes':
  5624                                                   CY_obj = dataset.createVariable('CY_Objects', np.float32,('time','yc','xc'),zlib=True)
  5625                                                   ACY_obj = dataset.createVariable('ACY_Objects', np.float32,('time','yc','xc'),zlib=True)
  5626                                                   SLP_real = dataset.createVariable('SLP', np.float32,('time','yc','xc'),zlib=True)
  5627         1         14.3     14.3      0.0      if tc_test == 'yes':
  5628                                                   TCs = dataset.createVariable('TC_Objects', np.float32,('time','yc','xc'),zlib=True)
  5629         1         15.4     15.4      0.0      if ms_test == 'yes':
  5630                                                   MS_real = dataset.createVariable('MS', np.float32,('time','yc','xc'),zlib=True)
  5631                                                   MS_obj = dataset.createVariable('MS_Objects', np.float32,('time','yc','xc'),zlib=True)
  5632         1         14.5     14.5      0.0      if ar_test == 'yes':
  5633                                                   IVT_real = dataset.createVariable('IVT', np.float32,('time','yc','xc'),zlib=True)
  5634                                                   IVT_obj = dataset.createVariable('IVT_Objects', np.float32,('time','yc','xc'),zlib=True)
  5635                                                   ARs = dataset.createVariable('AR_Objects', np.float32,('time','yc','xc'),zlib=True)
  5636         1         14.9     14.9      0.0      if z500_test == 'yes':
  5637                                                   CY_z500_obj = dataset.createVariable('CY_z500_Objects', np.float32,('time','yc','xc'),zlib=True)
  5638                                                   ACY_z500_obj = dataset.createVariable('ACY_z500_Objects', np.float32,('time','yc','xc'),zlib=True)
  5639                                                   Z500_real = dataset.createVariable('Z500', np.float32,('time','yc','xc'),zlib=True)
  5640         1         14.9     14.9      0.0      if col_test == 'yes':
  5641                                                   COL = dataset.createVariable('COL_Objects', np.float32,('time','yc','xc'),zlib=True)
  5642         1         15.0     15.0      0.0      if jet_test == 'yes':
  5643                                                   JET = dataset.createVariable('JET_Objects', np.float32,('time','yc','xc'),zlib=True)
  5644                                                   UV200 = dataset.createVariable('UV200', np.float32,('time','yc','xc'),zlib=True)
  5645         1         15.4     15.4      0.0      if ew_test == 'yes':
  5646                                                   MRG = dataset.createVariable('MRG_Objects', np.float32,('time','yc','xc'),zlib=True)
  5647                                                   IGW = dataset.createVariable('IGW_Objects', np.float32,('time','yc','xc'),zlib=True)
  5648                                                   KELVIN = dataset.createVariable('Kelvin_Objects', np.float32,('time','yc','xc'),zlib=True)
  5649                                                   EIG = dataset.createVariable('EIG0_Objects', np.float32,('time','yc','xc'),zlib=True)
  5650                                                   ER = dataset.createVariable('ER_Objects', np.float32,('time','yc','xc'),zlib=True)
  5651                                                   
  5652                                           
  5653         1         93.6     93.6      0.0      times.calendar = "standard"
  5654         1        215.4    215.4      0.0      times.units = "seconds since "+str(Time[0].year)+"-"+str(Time[0].month).zfill(2)+"-"+str(Time[0].day).zfill(2)+" "+str(Time[0].hour).zfill(2)+":"+str(Time[0].minute).zfill(2)+":00"
  5655         1         55.1     55.1      0.0      times.standard_name = "time"
  5656         1        129.1    129.1      0.0      times.long_name = "time"
  5657                                           
  5658         1         58.2     58.2      0.0      lat.long_name = "latitude" ;
  5659         1         45.9     45.9      0.0      lat.units = "degrees_north" ;
  5660         1         40.6     40.6      0.0      lat.standard_name = "latitude" ;
  5661                                           
  5662         1         37.0     37.0      0.0      lon.long_name = "longitude" ;
  5663         1         40.1     40.1      0.0      lon.units = "degrees_east" ;
  5664         1         37.9     37.9      0.0      lon.standard_name = "longitude" ;
  5665                                           
  5666         1         16.6     16.6      0.0      if mcs_tb_test == 'yes':
  5667         1         36.4     36.4      0.0          PR_real.coordinates = "lon lat"
  5668         1         35.5     35.5      0.0          PR_real.longname = "precipitation"
  5669         1         41.7     41.7      0.0          PR_real.unit = "mm/"+str(dT)+"h"
  5670                                                   
  5671                                                   # PR_obj.coordinates = "lon lat"
  5672                                                   # PR_obj.longname = "precipitation objects"
  5673                                                   # PR_obj.unit = ""
  5674                                                   
  5675                                           #         MCSs.coordinates = "lon lat"
  5676                                           #         MCSs.longname = "MCSs object defined by their precipitation"
  5677                                           #         MCSs.unit = ""
  5678                                                   
  5679         1         40.9     40.9      0.0          MCSs_Tb.coordinates = "lon lat"
  5680         1         44.9     44.9      0.0          MCSs_Tb.longname = "MCSs object defined by their Tb"
  5681         1         40.6     40.6      0.0          MCSs_Tb.unit = ""
  5682                                                   
  5683         1         40.9     40.9      0.0          Cloud_real.coordinates = "lon lat"
  5684         1         38.9     38.9      0.0          Cloud_real.longname = "Tb"
  5685         1         38.2     38.2      0.0          Cloud_real.unit = "K"
  5686                                                   
  5687                                                   # Cloud_obj.coordinates = "lon lat"
  5688                                                   # Cloud_obj.longname = "Tb objects"
  5689                                                   # Cloud_obj.unit = ""
  5690         1         15.9     15.9      0.0      if cloud_test == 'yes':
  5691         1         41.9     41.9      0.0          non_mcs_cloud_obj.coordinates = "lon lat"
  5692         1         39.8     39.8      0.0          non_mcs_cloud_obj.longname = "non MCS cloud object defined by their Tb"
  5693         1         38.3     38.3      0.0          non_mcs_cloud_obj.unit = ""
  5694         1         15.5     15.5      0.0      if front_test == 'yes':
  5695                                                   FR_real.coordinates = "lon lat"
  5696                                                   FR_real.longname = "frontal index"
  5697                                                   FR_real.unit = ""
  5698                                                   
  5699                                                   FR_obj.coordinates = "lon lat"
  5700                                                   FR_obj.longname = "frontal objects"
  5701                                                   FR_obj.unit = ""
  5702                                                   
  5703                                                   T_real.coordinates = "lon lat"
  5704                                                   T_real.longname = "850 hPa air temperature"
  5705                                                   T_real.unit = "K"
  5706         1         16.7     16.7      0.0      if slp_test == 'yes':
  5707                                                   CY_obj.coordinates = "lon lat"
  5708                                                   CY_obj.longname = "cyclone objects from SLP"
  5709                                                   CY_obj.unit = ""
  5710                                                   
  5711                                                   ACY_obj.coordinates = "lon lat"
  5712                                                   ACY_obj.longname = "anticyclone objects from SLP"
  5713                                                   ACY_obj.unit = ""
  5714                                                   
  5715                                                   SLP_real.coordinates = "lon lat"
  5716                                                   SLP_real.longname = "sea level pressure (SLP)"
  5717                                                   SLP_real.unit = "Pa"
  5718         1         17.1     17.1      0.0      if ms_test == 'yes':
  5719                                                   MS_real.coordinates = "lon lat"
  5720                                                   MS_real.longname = "850 hPa moisture flux"
  5721                                                   MS_real.unit = "g/g m/s"
  5722                                                   
  5723                                                   MS_obj.coordinates = "lon lat"
  5724                                                   MS_obj.longname = "mosture streams objects according to 850 hPa moisture flux"
  5725                                                   MS_obj.unit = ""
  5726         1         16.9     16.9      0.0      if ar_test == 'yes':
  5727                                                   IVT_real.coordinates = "lon lat"
  5728                                                   IVT_real.longname = "vertically integrated moisture transport"
  5729                                                   IVT_real.unit = "kg m1 s1"
  5730                                                   
  5731                                                   IVT_obj.coordinates = "lon lat"
  5732                                                   IVT_obj.longname = "IVT objects"
  5733                                                   IVT_obj.unit = ""
  5734                                                   
  5735                                                   ARs.coordinates = "lon lat"
  5736                                                   ARs.longname = "atmospheric river objects"
  5737                                                   ARs.unit = ""
  5738         1         22.5     22.5      0.0      if tc_test == 'yes':
  5739                                                   TCs.coordinates = "lon lat"
  5740                                                   TCs.longname = "tropical cyclone objects"
  5741                                                   TCs.unit = ""
  5742         1         17.8     17.8      0.0      if z500_test == 'yes':
  5743                                                   CY_z500_obj.coordinates = "lon lat"
  5744                                                   CY_z500_obj.longname = "cyclone objects according to Z500"
  5745                                                   CY_z500_obj.unit = ""
  5746                                                   
  5747                                                   ACY_z500_obj.coordinates = "lon lat"
  5748                                                   ACY_z500_obj.longname = "anticyclone objects according to Z500"
  5749                                                   ACY_z500_obj.unit = ""
  5750                                                   
  5751                                                   Z500_real.coordinates = "lon lat"
  5752                                                   Z500_real.longname = "500 hPa geopotential height"
  5753                                                   Z500_real.unit = "gpm"
  5754         1         18.2     18.2      0.0      if col_test == 'yes':
  5755                                                   COL.coordinates = "lon lat"
  5756                                                   COL.longname = "cut off low objects"
  5757                                                   COL.unit = ""
  5758         1         17.5     17.5      0.0      if jet_test == 'yes':
  5759                                                   JET.coordinates = "lon lat"
  5760                                                   JET.longname = "jet stream objects"
  5761                                                   JET.unit = ""
  5762                                                   
  5763                                                   UV200.coordinates = "lon lat"
  5764                                                   UV200.longname = "200 hPa wind speed"
  5765                                                   UV200.unit = "m s-1"
  5766         1         17.6     17.6      0.0      if ew_test == 'yes':
  5767                                                   MRG.coordinates = "lon lat"
  5768                                                   MRG.longname = "Mixed Rosby Gravity wave objects"
  5769                                                   MRG.unit = ""
  5770                                                   
  5771                                                   IGW.coordinates = "lon lat"
  5772                                                   IGW.longname = "Inertia Gravity wave objects"
  5773                                                   IGW.unit = ""
  5774                                                   
  5775                                                   KELVIN.coordinates = "lon lat"
  5776                                                   KELVIN.longname = "Kelvin wave objects"
  5777                                                   KELVIN.unit = ""
  5778                                                   
  5779                                                   EIG.coordinates = "lon lat"
  5780                                                   EIG.longname = "Eastward Inertio Gravirt wave objects"
  5781                                                   EIG.unit = ""
  5782                                                   
  5783                                                   ER.coordinates = "lon lat"
  5784                                                   ER.longname = "Equatorial Rossby wave objects"
  5785                                                   ER.unit = ""
  5786                                           
  5787         1       3686.4   3686.4      0.0      lat[:] = Lat
  5788         1       3552.9   3552.9      0.0      lon[:] = Lon
  5789         1         18.3     18.3      0.0      if mcs_tb_test == 'yes':
  5790         1    1112371.7 1.11e+06      5.7          PR_real[:] = pr
  5791                                                   # PR_obj[:] = PR_objects
  5792                                                   # MCSs[:] = MCS_obj
  5793         1     482253.8 482253.8      2.5          MCSs_Tb[:] = MCS_objects_Tb
  5794         1    2058764.4 2.06e+06     10.6          Cloud_real[:] = tb
  5795                                                   # Cloud_obj[:] = C_objects
  5796         1         32.2     32.2      0.0      if cloud_test == 'yes':
  5797         1     505036.5 505036.5      2.6          non_mcs_cloud_obj[:] = cloud_objects
  5798         1         27.4     27.4      0.0      if front_test == 'yes':
  5799                                                   FR_real[:] = Frontal_Diagnostic
  5800                                                   FR_obj[:] = FR_objects
  5801                                                   T_real[:] = t850
  5802         1         19.7     19.7      0.0      if tc_test == 'yes':
  5803                                                   TCs[:] = TC_obj
  5804         1         18.9     18.9      0.0      if slp_test == 'yes':
  5805                                                   CY_obj[:] = CY_objects
  5806                                                   ACY_obj[:] = ACY_objects
  5807                                                   SLP_real[:] = slp
  5808         1         19.0     19.0      0.0      if ms_test == 'yes':
  5809                                                   MS_real[:] = VapTrans
  5810                                                   MS_obj[:] = MS_objects
  5811         1         18.6     18.6      0.0      if ar_test == 'yes':
  5812                                                   IVT_real[:] = IVT
  5813                                                   IVT_obj[:] = IVT_objects
  5814                                                   ARs[:] = AR_obj
  5815         1         18.1     18.1      0.0      if z500_test == 'yes':
  5816                                                   CY_z500_obj[:] = cy_z500_objects
  5817                                                   ACY_z500_obj[:] = acy_z500_objects
  5818                                                   Z500_real[:] = z500
  5819         1         17.5     17.5      0.0      if col_test == 'yes':
  5820                                                   COL[:] = col_obj
  5821         1         25.7     25.7      0.0      if jet_test == 'yes':
  5822                                                   JET[:] = jet_objects
  5823                                                   UV200[:] = uv200
  5824         1         18.7     18.7      0.0      if ew_test == 'yes':
  5825                                                   MRG[:] = mrg_objects
  5826                                                   IGW[:] = igw_objects
  5827                                                   KELVIN[:] = kelvin_objects
  5828                                                   EIG[:] = eig0_objects
  5829                                                   ER[:] = er_objects
  5830                                                           
  5831         1        760.0    760.0      0.0      times[:] = iTime
  5832                                               
  5833                                               # SET GLOBAL ATTRIBUTES
  5834                                               # Add global attributes
  5835         1     760105.6 760105.6      3.9      dataset.title = "MOAAP object tracking output"
  5836         1        275.0    275.0      0.0      dataset.contact = "Andreas F. Prein (prein@ucar.edu)"
  5837                                               # dataset.breakup = 'The ' + breakup + " method has been used to segment the objects"
  5838                                           
  5839         1      45633.7  45633.7      0.2      dataset.close()
  5840         1         34.6     34.6      0.0      print('Saved: '+NCfile)
  5841         1         23.3     23.3      0.0      import time
  5842         1         20.8     20.8      0.0      end = time.perf_counter()
  5843         1         46.6     46.6      0.0      timer(start, end)
  5844                                           
  5845         1         20.8     20.8      0.0      if tc_test == 'yes':
  5846                                                   ### SAVE THE TC TRACKS TO PICKL FILE
  5847                                                   # ============================
  5848                                                   a_file = open(params["OutputFolder"]+str(Time[0].year)+str(Time[0].month).zfill(2)+'_TCs_tracks.pkl', "wb")
  5849                                                   pickle.dump(TC_Tracks, a_file)
  5850                                                   a_file.close()
  5851                                                   
  5852         1         71.6     71.6      0.0      if 'object_split' in locals():
  5853                                                   return object_split
  5854                                               else:
  5855         1         19.1     19.1      0.0          object_split = None
  5856         1          9.7      9.7      0.0          return object_split

Total time: 23.9568 s
File: 2d_vs_3d.py
Function: main at line 9

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     9                                           @profile
    10                                           def main():
    11         2          3.9      2.0      0.0    object_names = [['cold clouds', '#737373', '-', 2],
    12         1          1.2      1.2      0.0                    ['surface cyclones', 'k', '-', 2],
    13         1          1.0      1.0      0.0                    ['mid-level cyclones', 'k', '--', 2],
    14         1          0.9      0.9      0.0                    ['anticyclones', '#ff7f00', '-', 2],
    15         1          0.9      0.9      0.0                    ['MCS', '#33a02c', '-', 2],
    16         1          1.0      1.0      0.0                    ['moisture streams', 'r', '-', 2],
    17         1          0.9      0.9      0.0                    ['jets', '#6a3d9a', '-', 2],
    18         1          0.9      0.9      0.0                    ['Rossby waves', '#8c510a', '-', 3],
    19         1          0.8      0.8      0.0                    ['mixed Rossby gravity waves', '#bf812d', '-', 1.5],
    20         1          1.2      1.2      0.0                    ['inertia gravity waves', '#dfc27d','-', 3],
    21         1          0.8      0.8      0.0                    ['Kelvin waves', '#abd9e9','-', 1.5],
    22         1          0.9      0.9      0.0                    ['eastward inertia gravity waves', '#4575b4', '-', 3],
    23         1          0.9      0.9      0.0                    ['fronts', '#cab2d6', '-', 2]]
    24                                           
    25                                           
    26         1    2414718.9 2.41e+06     10.1    data_vars = xr.open_dataset('20210701-04_MOAAP-Input_24h.nc')
    27                                           
    28         1          1.5      1.5      0.0    dT = 1 # time interval of input files [hours]
    29         1       7168.9   7168.9      0.0    Mask = np.copy(data_vars['lon']); Mask[:]=1 # tracking is applied globally
    30         1          1.2      1.2      0.0    DataName = 'ERA5'
    31         1       2004.2   2004.2      0.0    time_datetime = pd.to_datetime(np.array(data_vars['time'].values, dtype='datetime64'))
    32                                           
    33        18   19511376.7 1.08e+06     81.4    object_split = moaap(
    34         1        116.2    116.2      0.0                          data_vars['lon'],
    35         1         87.9     87.9      0.0                          data_vars['lat'],
    36         1          0.5      0.5      0.0                          time_datetime,
    37         1          0.5      0.5      0.0                          dT,
    38         1          0.4      0.4      0.0                          Mask,
    39                                                                   # v850 =  data_vars['V850'].values,
    40                                                                   # u850 = data_vars['U850'].values,
    41                                                                   # t850 = data_vars['T850'].values,
    42                                                                   # q850 = data_vars['Q850'].values,
    43                                                                   # slp = data_vars['SLP'].values,
    44                                                                   # ivte = data_vars['IVTE'].values,
    45                                                                   # ivtn = data_vars['IVTN'].values,
    46                                                                   # z500 = data_vars['Z500'].values,
    47                                                                   # v200 = data_vars['V200'].values,
    48                                                                   # u200 = data_vars['U200'].values,
    49         1          0.6      0.6      0.0                          v850 =None, #  data_vars['V850'],
    50         1          0.6      0.6      0.0                          u850 = None, #data_vars['U850'],
    51         1          0.5      0.5      0.0                          t850 = None, #data_vars['T850'],
    52         1          0.4      0.4      0.0                          q850 = None, #data_vars['Q850'],
    53         1          0.4      0.4      0.0                          slp = None, #data_vars['SLP'],
    54         1          0.8      0.8      0.0                          ivte = None, #data_vars['IVTE'],
    55         1          0.5      0.5      0.0                          ivtn = None, #data_vars['IVTN'],
    56         1          0.4      0.4      0.0                          z500 = None, #data_vars['Z500'],
    57         1          0.5      0.5      0.0                          v200 = None, #data_vars['V200'],
    58         1          0.4      0.4      0.0                          u200 = None, #data_vars['U200'],
    59         1      48505.8  48505.8      0.2                          pr   = data_vars['PR'].values,
    60         1      49342.6  49342.6      0.2                          tb   = data_vars['Tb'].values,
    61         1          0.7      0.7      0.0                          DataName = DataName,
    62         1          0.8      0.8      0.0                          OutputFolder = 'moaap_output/',
    63         1          0.7      0.7      0.0                          js_min_anomaly = 12,
    64         1          0.6      0.6      0.0                          MinTimeJS = 12,
    65                                                                     )
    66                                           
    67                                           
    68         1      16124.8  16124.8      0.1    data_moaap = xr.open_dataset('moaap_output/202107_ERA5_ObjectMasks__dt-1h_MOAAP-masks.nc')
    69         1          2.4      2.4      0.0    import pickle
    70         2         36.1     18.1      0.0    with open('moaap_output/MCSs_202107__dt-1h_MOAAP-masks.pkl', 'rb') as f:
    71         1       3480.9   3480.9      0.0        mcs_charac = pickle.load(f)
    72                                           
    73         1          4.6      4.6      0.0    import cartopy.crs as ccrs
    74         1          4.8      4.8      0.0    import matplotlib.pyplot as plt
    75                                           
    76                                             # Create a figure and axis with a PlateCarree projection (latitude and longitude)
    77         2     408134.5 204067.2      1.7    fig, ax = plt.subplots(subplot_kw={'projection': ccrs.PlateCarree()},
    78         1          0.9      0.9      0.0                          figsize=(14,6))
    79                                           
    80                                             # Set the extent of the map (in this case, the entire globe)
    81         1       1676.9   1676.9      0.0    ax.set_extent([-180, 180, -90, 90], crs=ccrs.PlateCarree())
    82                                           
    83                                             # Add coastlines and gridlines for reference
    84         1       1490.2   1490.2      0.0    ax.coastlines(color='#969696')
    85         1       5670.1   5670.1      0.0    ax.gridlines()
    86                                           
    87                                             # Generate some random data (latitude, longitude, and values)
    88         1      10778.6  10778.6      0.0    mcs_mask = np.array(data_moaap['MCS_Tb_Objects'][12,:,:])
    89         1       1532.0   1532.0      0.0    mcs_mask[mcs_mask == 0] = np.nan
    90         2     468631.5 234315.8      2.0    sc = plt.pcolormesh(data_moaap['lon'],
    91         1         67.6     67.6      0.0                        data_moaap['lat'],
    92         1          0.8      0.8      0.0                        mcs_mask,
    93         1          0.6      0.6      0.0                        cmap = 'nipy_spectral')
    94                                           
    95                                           
    96                                             # plot MCS tracks
    97       101         94.5      0.9      0.0    for ii in range(len(mcs_charac.keys())):
    98       100        325.9      3.3      0.0      LatLonTrack = mcs_charac[list(mcs_charac.keys())[ii]]['track']
    99       100     210291.6   2102.9      0.9      plt.plot(LatLonTrack[:,1],LatLonTrack[:,0], transform=ccrs.PlateCarree(), lw=1, color='k')
   100                                           
   101         1       9308.8   9308.8      0.0    ax.set_extent([-180, 180, -70, 70], crs=ccrs.PlateCarree())
   102                                           
   103                                             # Add a colorbar to the plot
   104         1      52005.6  52005.6      0.2    cbar = plt.colorbar(sc, ax=ax, orientation='vertical', shrink=0.7, label='MCS mask')
   105                                           
   106                                             # Set the title of the plot
   107         1        773.9    773.9      0.0    plt.title('MCS tracks (black lines) and masks at '+str(time_datetime[12])[:16])
   108                                           
   109         1     733009.7 733009.7      3.1    plt.savefig("MCS_tracks_masks_3d.png")
   110                                           
   111         1          1.1      1.1      0.0    print_gif = False
   112         1          6.4      6.4      0.0    if print_gif:
   113                                               for tt in tqdm(range(len(time_datetime))):
   114                                           
   115                                                 # Create a figure and axis with a PlateCarree projection (latitude and longitude)
   116                                                 fig, ax = plt.subplots(subplot_kw={'projection': ccrs.PlateCarree()},
   117                                                                       figsize=(14,6))
   118                                           
   119                                                 # Set the extent of the map (in this case, the entire globe)
   120                                                 # ax.set_extent([-180, 180, -90, 90], crs=ccrs.PlateCarree())
   121                                           
   122                                                 # Add coastlines and gridlines for reference
   123                                                 ax.coastlines(color='#969696')
   124                                                 ax.gridlines()
   125                                           
   126                                                 # Define mapping of object types to colors/styles
   127                                                 object_plotting_config = {
   128                                                     'MCS_Tb_Objects': {'colors': '#33a02c', 'threshold': 0, 'linewidth': 1},
   129                                                     'CY_Objects': {'colors': 'k', 'threshold': 0, 'linewidth': 1},
   130                                                     'COL_Objects': {'colors': 'k', 'threshold': 0, 'linewidth': 1, 'linestyles': '--'},
   131                                                     'ACY_Objects': {'colors': '#ff7f00', 'threshold': 0, 'linewidth': 1},
   132                                                     'JET_Objects': {'colors': '#6a3d9a', 'threshold': 0, 'linewidth': 1},
   133                                                     'AR_Objects': {'colors': 'r', 'threshold': 0, 'linewidth': 1},
   134                                                     'FR_Objects': {'colors': '#cab2d6', 'threshold': 1, 'linewidth': 0.5},
   135                                                     'ER_Objects': {'colors': '#8c510a', 'threshold': 1, 'linewidth': 0.5}
   136                                                 }
   137                                           
   138                                                 # Plot only available objects
   139                                                 for obj_name, config in object_plotting_config.items():
   140                                                     if obj_name in data_moaap.data_vars:
   141                                                         plot_args = {
   142                                                             'colors': config['colors'],
   143                                                             'levels': range(0, 2, 1),
   144                                                             'linewidths': config.get('linewidth', 1)
   145                                                         }
   146                                                         if 'linestyles' in config:
   147                                                             plot_args['linestyles'] = config['linestyles']
   148                                                             
   149                                                         sc = plt.contour(data_moaap['lon'],
   150                                                                         data_moaap['lat'],
   151                                                                         np.array(data_moaap[obj_name][tt,:,:]) > config['threshold'],
   152                                                                         **plot_args)
   153                                           
   154                                                 # Set the title of the plot
   155                                                 plt.title('Objects identied by MOAAP at '+str(time_datetime[tt])[:16])
   156                                           
   157                                                 # create legend
   158                                                 for ob in range(len(object_names)):
   159                                                   plt.plot([],[], color = object_names[ob][1], \
   160                                                           linestyle = object_names[ob][2],\
   161                                                           lw = object_names[ob][3],\
   162                                                           label = object_names[ob][0])
   163                                           
   164                                                 # plt.legend()
   165                                                 ax.legend(bbox_to_anchor=(1, 0.00), ncol=4)
   166                                           
   167                                           
   168                                                 # Show the plot
   169                                                 fig.savefig('images/'+str(tt).zfill(3)+'_CausesOfExtreme_100_daily-extremes.jpg', bbox_inches='tight', dpi=100)
   170                                           
   171                                                 import glob
   172                                           
   173                                                 from PIL import Image
   174                                                 def make_gif(frame_folder):
   175                                                     frames = [Image.open(image) for image in np.sort(glob.glob(f"{frame_folder}/*.jpg"))]
   176                                                     frame_one = frames[0]
   177                                                     frame_one.save("phenomenon.gif", format="GIF", append_images=frames,
   178                                                             save_all=True, duration=100, loop=0)
   179                                           
   180                                                 make_gif("images/")

Okay, I've analyzed the lineprofiler_mcs.txt file. Here's a breakdown of the major time consumers:

**1. `watershed_3d_overlap` function:**

*   This function is called from both `mcs_tb_tracking` and `cloud_tracking`.
*   Within `mcs_tb_tracking`, line 3025 `C_objects = watershed_3d_overlap(...)` takes a significant 66.8% of the time within that function (3.79 seconds total).
*   Within `cloud_tracking`, line 3164 `cloud_objects = watershed_3d_overlap(...)` consumes 90.0% of the time within that function (2.83 seconds total).
*   This indicates that `watershed_3d_overlap` is a major bottleneck.

**2. `label_peaks_over_time_3d` function:**

*   This function is called by `watershed_3d_overlap`.
*   Line 4213 `dist, idx = tree.query(peak, distance_upper_bound=max_dist)` within `label_peaks_over_time_3d` takes 94.0% of the time within that function (6.62 seconds total). This is a very significant bottleneck *within* the watershedding process.

**3. `mcs_tb_tracking` function:**

*   Line 4269 `MCS_objects_Tb, C_objects = mcs_tb_tracking(...)` takes 29.3% of the time within that function (5.71 seconds total).

**4. `calc_grid_distance_area` function:**

*   Line 4995 `_,_,Area,Gridspacing = calc_grid_distance_area(Lon,Lat)` takes 1.0% of the time within that function (0.19 seconds total).

**5. `clean_up_objects` function:**

*   Line 3111 `MCS_objects_Tb, _ = clean_up_objects(MCS_objects_Tb, ...)` takes 2.6% of the time within that function (0.14 seconds total).
*   Line 2167 `object_indices = ndimage.find_objects(DATA)` takes 57.0% of the time within that function (0.07 seconds total).
*   Line 2173 `objectsTMP = np.zeros_like(DATA)` takes 24.7% of the time within that function (0.03 seconds total).

**Summary of Bottlenecks and Potential Optimization Areas:**

1.  **`watershed_3d_overlap` and `label_peaks_over_time_3d`:** These are the most critical bottlenecks. Focus on optimizing the `watershed` function and the KDTree query within `label_peaks_over_time_3d`.
2.  **`mcs_tb_tracking`:** Optimizing this function could also yield significant improvements, given its high total time.
3.  **`calc_grid_distance_area`:** Optimizing this function could also yield significant improvements, given its high total time.
4.  **`clean_up_objects`:** Optimizing this function could also yield significant improvements, given its high total time.

**Recommendations:**

*   **Optimize `label_peaks_over_time_3d`:** Explore alternative methods for finding nearest neighbors that might be faster than `cKDTree`, or try to reduce the number of peaks being processed.
*   **Optimize `watershed_3d_overlap`:** Consider whether the watershedding parameters are appropriate for the data, and if there are ways to reduce the complexity of the watershedding process (e.g., by smoothing the input data more aggressively).
*   **Profile Deeper:** Use `line_profiler` or other profiling tools to investigate the time spent *within* the `watershed` function itself.
*   **Consider Alternative Libraries:** Explore other watershedding implementations that might be more performant.
*   **Vectorization:** Ensure that all possible calculations are vectorized using NumPy.
*   **Data Types:** Verify that the data types being used are the most efficient for the calculations being performed.
*   **Parallelization:** Explore opportunities to parallelize the watershedding process, as it is applied independently to each time step.
*   **Caching:** If possible, cache intermediate results to avoid redundant calculations.

By focusing on these key areas, you should be able to achieve significant performance improvements in your code.