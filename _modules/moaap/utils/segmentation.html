

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>moaap.utils.segmentation &mdash; MOAAP  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MOAAP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">MOAAP Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">MOAAP: Multi-Object Analysis of Atmospheric Phenomena - Tutorial</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MOAAP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">moaap.utils.segmentation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for moaap.utils.segmentation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">DefaultDict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">center_of_mass</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.feature</span><span class="w"> </span><span class="kn">import</span> <span class="n">peak_local_max</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">watershed</span><span class="p">,</span> <span class="n">find_boundaries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span> <span class="c1"># pyright: ignore[reportMissingModuleSource]</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.morphology</span><span class="w"> </span><span class="kn">import</span> <span class="n">erosion</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">dilation</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">psutil</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpatches</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">shared_memory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pdb</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_trace</span> <span class="k">as</span> <span class="n">stop</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">moaap.utils.object_props</span><span class="w"> </span><span class="kn">import</span> <span class="n">clean_up_objects</span><span class="p">,</span> <span class="n">ConnectLon_on_timestep</span>



<div class="viewcode-block" id="UnionFind">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.UnionFind">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UnionFind</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Union-Find (Disjoint Set) data structure.</span>
<span class="sd">    Assumes each &#39;label&#39; (int) is a unique object ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="UnionFind.add">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.UnionFind.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span></div>


<div class="viewcode-block" id="UnionFind.find">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.UnionFind.find">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">item</span><span class="p">]</span></div>


<div class="viewcode-block" id="UnionFind.union">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.UnionFind.union">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">item2</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">root1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span>
        <span class="n">root2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">item2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root1</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root2</span></div>
</div>




<div class="viewcode-block" id="connect_3d_objects">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.connect_3d_objects">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">connect_3d_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_tsteps</span><span class="p">,</span> <span class="n">dT</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Links 2D labeled slices into 3D objects based on maximum spatial overlap </span>
<span class="sd">    between consecutive time steps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : np.ndarray</span>
<span class="sd">        3D array where each [t, :, :] slice contains independent 2D labels.</span>
<span class="sd">    min_tsteps : int</span>
<span class="sd">        Minimum duration to keep an object.</span>
<span class="sd">    dT : int</span>
<span class="sd">        Time step.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    objects_watershed : np.ndarray</span>
<span class="sd">        3D array with consistent object IDs tracked over time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">objects_watershed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">objects_watershed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">next_id</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">)):</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">objects_watershed</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

        <span class="c1"># build overlap counts</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">curr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">pair_idx</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">pair_idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="p">)</span>

        <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">counts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p_lbls</span> <span class="o">=</span> <span class="n">nz</span> <span class="o">//</span> <span class="n">M</span>
        <span class="n">c_lbls</span> <span class="o">=</span> <span class="n">nz</span> <span class="o">%</span> <span class="n">M</span>
        <span class="n">overlaps</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">nz</span><span class="p">]</span>

        <span class="c1"># greedy best‐overlap assignment</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">overlaps</span><span class="p">)</span>
        <span class="n">p_lbls</span> <span class="o">=</span> <span class="n">p_lbls</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">c_lbls</span> <span class="o">=</span> <span class="n">c_lbls</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">used_curr</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p_lbl</span><span class="p">,</span> <span class="n">c_lbl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p_lbls</span><span class="p">,</span> <span class="n">c_lbls</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p_lbl</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c_lbl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">p_lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span> <span class="ow">and</span> <span class="n">c_lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_curr</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">p_lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_lbl</span>
                <span class="n">used_curr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_lbl</span><span class="p">)</span>

        <span class="c1"># build the new t‐slice</span>
        <span class="n">new_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># 1) continuing objects</span>
        <span class="k">for</span> <span class="n">p_lbl</span><span class="p">,</span> <span class="n">c_lbl</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_slice</span><span class="p">[</span><span class="n">curr</span> <span class="o">==</span> <span class="n">c_lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_lbl</span>

        <span class="c1"># 2) brand‐new objects</span>
        <span class="n">all_curr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c_lbl</span> <span class="ow">in</span> <span class="n">all_curr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c_lbl</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c_lbl</span> <span class="ow">in</span> <span class="n">used_curr</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_slice</span><span class="p">[</span><span class="n">curr</span> <span class="o">==</span> <span class="n">c_lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_id</span>
            <span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">objects_watershed</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_slice</span>

    <span class="c1"># finally do your cleanup</span>
    <span class="n">objects_watershed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">clean_up_objects</span><span class="p">(</span><span class="n">objects_watershed</span><span class="p">,</span>
                                         <span class="n">min_tsteps</span><span class="o">=</span><span class="n">min_tsteps</span><span class="p">,</span>
                                         <span class="n">dT</span><span class="o">=</span><span class="n">dT</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">objects_watershed</span></div>




<span class="k">def</span><span class="w"> </span><span class="nf">_get_all_centers_by_time</span><span class="p">(</span>
    <span class="n">labeled_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span> 
         <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
         <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the 2D center for every label at every time slice it appears.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labeled_data : np.ndarray</span>
<span class="sd">        3D array of labeled data, shape (T, H, W).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple :</span>
<span class="sd">        - centers_by_label : DefaultDict[int, Dict[int, Tuple[float, float]]]</span>
<span class="sd">            Mapping of label -&gt; time -&gt; (y_center, x_center).</span>
<span class="sd">        - labels_by_time : DefaultDict[int, List[int]]</span>
<span class="sd">            Mapping of time -&gt; list of labels present at that time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pre-calculating all label 2D centers at each time slice...&quot;</span><span class="p">)</span>
    <span class="n">centers_by_label</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">labels_by_time</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="n">num_times</span> <span class="o">=</span> <span class="n">labeled_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Iterate over time slices to compute centers via center of mass</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
        <span class="n">label_slice</span> <span class="o">=</span> <span class="n">labeled_data</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">labels_in_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_slice</span><span class="p">)</span>
        <span class="n">labels_in_slice</span> <span class="o">=</span> <span class="n">labels_in_slice</span><span class="p">[</span><span class="n">labels_in_slice</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">labels_in_slice</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">centers</span> <span class="o">=</span> <span class="n">center_of_mass</span><span class="p">(</span><span class="n">label_slice</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">label_slice</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels_in_slice</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">labels_in_slice</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">centers</span><span class="p">]</span> <span class="c1"># Handle single label case</span>

        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_in_slice</span><span class="p">,</span> <span class="n">centers</span><span class="p">):</span>
            <span class="n">centers_by_label</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">labels_by_time</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">centers_by_label</span><span class="p">,</span> <span class="n">labels_by_time</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_find_nearest_neighbor</span><span class="p">(</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">labels_by_time</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">centers_by_label</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the nearest neighbor label at a given time slice to the provided center.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : np.ndarray</span>
<span class="sd">        2D center point (y, x).</span>
<span class="sd">    time : int</span>
<span class="sd">        Time slice to search for neighbors.</span>
<span class="sd">    labels_by_time : List[int]</span>
<span class="sd">        List of labels present at the given time slice.</span>
<span class="sd">    centers_by_label : DefaultDict[int, Dict[int, Tuple[float, float]]]</span>
<span class="sd">        Precomputed centers for each label at each time slice.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple : [int, float]</span>
<span class="sd">        A tuple of (nearest_label, distance). If no labels exist at that time, returns (None, inf).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nearest_label</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels_by_time</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_distance</span>

    <span class="c1"># Calculate distances to all labels at the given time and find the nearest</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels_by_time</span><span class="p">:</span>
        <span class="n">actual_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers_by_label</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">time</span><span class="p">])</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">actual_center</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="n">nearest_label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">return</span> <span class="n">nearest_label</span><span class="p">,</span> <span class="n">min_distance</span>



<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<div class="viewcode-block" id="build_object_history_dict">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.build_object_history_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_object_history_dict</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">histories</span><span class="p">,</span> <span class="n">object_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build per-object history records (lifetime + interactions) from watershed tracking outputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : array-like of int</span>
<span class="sd">        All nonzero object labels.</span>
<span class="sd">    centers : dict</span>
<span class="sd">        centers[label][t] -&gt; (y, x) or similar. Used only to infer lifetimes.</span>
<span class="sd">    events : list of dict</span>
<span class="sd">        Each event dict must have keys:</span>
<span class="sd">        - &#39;type&#39; in {&#39;merge&#39;,&#39;split&#39;}</span>
<span class="sd">        - &#39;time&#39; (int)</span>
<span class="sd">        - &#39;from_label&#39; (int)</span>
<span class="sd">        - &#39;to_label&#39; (int)</span>
<span class="sd">        - &#39;distance&#39; (float)</span>
<span class="sd">    uf : UnionFind</span>
<span class="sd">        Must implement uf.find(label) and have uf.parent mapping.</span>
<span class="sd">    histories : dict[int, set[int]]</span>
<span class="sd">        Root -&gt; set of labels connected by merges/splits.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    object_data : dict[int, dict]</span>
<span class="sd">        object_data[label] is the record for that object label.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>

    <span class="c1"># lifetimes from centers</span>
    <span class="n">label_times</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">label_times</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="k">if</span> <span class="n">ts</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># interactions per label</span>
    <span class="n">interactions</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="n">etype</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;from_label&quot;</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;to_label&quot;</span><span class="p">])</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">])</span>

        <span class="n">interactions</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">etype</span><span class="p">,</span> <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;from&quot;</span><span class="p">,</span> <span class="s2">&quot;other_label&quot;</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">dist</span><span class="p">})</span>
        <span class="n">interactions</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">etype</span><span class="p">,</span> <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;to&quot;</span><span class="p">,</span>   <span class="s2">&quot;other_label&quot;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">dist</span><span class="p">})</span>

    <span class="c1"># union-find group info</span>
    <span class="n">label_root</span> <span class="o">=</span> <span class="p">{</span><span class="n">lab</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">lab</span><span class="p">))</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>
    <span class="n">root_members</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">members</span><span class="p">)</span> <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">members</span> <span class="ow">in</span> <span class="n">histories</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># assemble object_data</span>
    <span class="n">object_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">label_times</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
        <span class="n">evs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">interactions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="p">[]),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">t1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">partners</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;other_label&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">evs</span><span class="p">})</span>
        <span class="n">n_partners</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">partners</span><span class="p">)</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">label_root</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
        <span class="n">object_data</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">lab</span><span class="p">,</span>
            <span class="s2">&quot;lifetime&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;t_start&quot;</span><span class="p">:</span> <span class="n">t0</span><span class="p">,</span> <span class="s2">&quot;t_end&quot;</span><span class="p">:</span> <span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">},</span>
            <span class="s2">&quot;root&quot;</span><span class="p">:</span> <span class="n">root</span><span class="p">,</span>
            <span class="s2">&quot;group_labels&quot;</span><span class="p">:</span> <span class="n">root_members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">[</span><span class="n">lab</span><span class="p">]),</span>
            <span class="s2">&quot;n_interactions&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">evs</span><span class="p">),</span>
            <span class="s2">&quot;unique_partners&quot;</span><span class="p">:</span> <span class="n">partners</span><span class="p">,</span>
            <span class="s2">&quot;n_unique_partners&quot;</span><span class="p">:</span> <span class="n">n_partners</span><span class="p">,</span>
            <span class="s2">&quot;interactions&quot;</span><span class="p">:</span> <span class="n">evs</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># lossless, recommended</span>
        <span class="n">pkl_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;object_history_</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s2">.pkl&quot;</span> <span class="k">if</span> <span class="n">object_type</span> <span class="k">else</span> <span class="s2">&quot;object_history.pkl&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">pkl_name</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">object_data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>

        <span class="c1"># optional human-readable JSON (keys become strings)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_jsonify</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,)):</span> <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">,)):</span> <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">json_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;object_history_</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s2">.json&quot;</span> <span class="k">if</span> <span class="n">object_type</span> <span class="k">else</span> <span class="s2">&quot;object_history.json&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">json_name</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="p">{</span><span class="n">kk</span><span class="p">:</span> <span class="n">_jsonify</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">object_data</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                      <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">object_data</span></div>



<div class="viewcode-block" id="analyze_watershed_history">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.analyze_watershed_history">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">analyze_watershed_history</span><span class="p">(</span><span class="n">watershed_results</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">object_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">histplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analyze the history of watershed objects over time.</span>
<span class="sd">    The output is a union of all objects which merged or split over time, </span>
<span class="sd">    along with a list of events (merges and splits) that occurred and the history array</span>
<span class="sd">    (dict of sets), where two labels are in one set if they are connected via merges/splits.</span>
<span class="sd">    This is done via Euler-timestepping and comparing the overlap of objects.</span>
<span class="sd">    This function also creates a plot of the history of all objects showing merges and splits of </span>
<span class="sd">    at most 40 objects (for better readability).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    watershed_results : np.ndarray</span>
<span class="sd">        3D array of watershed labels over time, shape (T, H, W).</span>
<span class="sd">    min_dist : float</span>
<span class="sd">        Minimum distance threshold to consider two objects as related (for merges/splits).</span>
<span class="sd">    object_type : str</span>
<span class="sd">        Type of object being analyzed (e.g., &quot;mcs&quot;, &quot;cloud&quot;).</span>
<span class="sd">    histplot : bolean</span>
<span class="sd">        Switch to turn on plotting of object history</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_array : Dict[int, int]</span>
<span class="sd">        Mapping of each label to its root label in the union-find structure.</span>
<span class="sd">    events : List[Dict[str, Any]]</span>
<span class="sd">        List of merge and split events with details.</span>
<span class="sd">    histories : Dict[int, Set[int]]</span>
<span class="sd">        Dictionary mapping root labels to sets of all connected labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create Union-Find structure</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">watershed_results</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">watershed_results</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">centers</span><span class="p">,</span> <span class="n">labels_t</span> <span class="o">=</span> <span class="n">_get_all_centers_by_time</span><span class="p">(</span><span class="n">watershed_results</span><span class="p">)</span>

    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">uf</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span> 
        <span class="n">times_present</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">times_present</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">t_start</span> <span class="o">=</span> <span class="n">times_present</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_end</span> <span class="o">=</span> <span class="n">times_present</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping label&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="s2">&quot;with insufficient time span&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># check for split genesis</span>
        <span class="n">center_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t_start</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">t_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">center_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">center_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t_start</span><span class="p">])</span>

            <span class="c1"># previous center prediction, c_-1 = c_0 - v * dt, v = (c_1 - c_0) / dt</span>
            <span class="c1"># hence, c_-1 = 2 * c_0 - c_1</span>
            <span class="n">pred_center</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">center_start</span> <span class="o">-</span> <span class="n">center_next</span>

            <span class="n">nearest_label</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">_find_nearest_neighbor</span><span class="p">(</span>
                <span class="n">pred_center</span><span class="p">,</span>
                <span class="n">t_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">labels_t</span><span class="p">[</span><span class="n">t_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">centers</span>
            <span class="p">)</span>

            <span class="c1"># If a nearby label is found within min_dist, consider it a split</span>
            <span class="k">if</span> <span class="n">nearest_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">nearest_label</span><span class="p">)</span>
                <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;split&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">t_start</span><span class="p">,</span>
                    <span class="s1">&#39;from_label&#39;</span><span class="p">:</span> <span class="n">nearest_label</span><span class="p">,</span>
                    <span class="s1">&#39;to_label&#39;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span>
                    <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist</span>
                <span class="p">})</span>

        <span class="k">if</span> <span class="n">t_end</span> <span class="o">&lt;</span> <span class="n">T</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">center_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">center_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t_end</span><span class="p">])</span>
            <span class="n">center_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">t_end</span><span class="p">])</span>

            <span class="c1"># next center prediction, c_+1 = c_0 + v * dt, v = (c_0 - c_-1) / dt</span>
            <span class="c1"># hence, c_+1 = 2 * c_0 - c_-1</span>
            <span class="n">pred_center</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">center_end</span> <span class="o">-</span> <span class="n">center_prev</span>

            <span class="n">nearest_label</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">_find_nearest_neighbor</span><span class="p">(</span>
                <span class="n">pred_center</span><span class="p">,</span>
                <span class="n">t_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">labels_t</span><span class="p">[</span><span class="n">t_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">centers</span>
            <span class="p">)</span>

            <span class="c1"># If a nearby label is found within min_dist, consider it a merge</span>
            <span class="k">if</span> <span class="n">nearest_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">nearest_label</span><span class="p">)</span>
                <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;merge&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">t_end</span><span class="p">,</span>
                    <span class="s1">&#39;from_label&#39;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span>
                    <span class="s1">&#39;to_label&#39;</span><span class="p">:</span> <span class="n">nearest_label</span><span class="p">,</span>
                    <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist</span>
                <span class="p">})</span>

    <span class="c1"># Build histories</span>
    <span class="n">histories</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">histories</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="n">union_array</span> <span class="o">=</span> <span class="n">uf</span><span class="o">.</span><span class="n">parent</span>

    <span class="c1"># get object histories into a directory</span>
    <span class="n">history_data</span> <span class="o">=</span> <span class="n">build_object_history_dict</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">histories</span><span class="p">,</span> <span class="n">object_type</span><span class="o">=</span><span class="n">object_type</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">histplot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Plot the history</span>
        <span class="c1"># Collect all unique labels and their lifetimes</span>
        <span class="n">all_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">histories</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">all_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">label_times</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">all_labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">centers</span><span class="p">:</span>
                <span class="n">times</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">label_times</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
    
        <span class="c1"># Filter to only labels involved in events (merges or splits)</span>
        <span class="n">event_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">event_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;from_label&#39;</span><span class="p">])</span>
            <span class="n">event_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;to_label&#39;</span><span class="p">])</span>
        <span class="n">filtered_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">all_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">event_labels</span><span class="p">]</span>
        <span class="n">filtered_label_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">label_times</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">filtered_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_times</span><span class="p">}</span>
    
        <span class="c1"># Group filtered_labels by their history root and sort within groups and between groups</span>
        <span class="n">label_to_root</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">histories</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">filtered_labels</span><span class="p">:</span>
                    <span class="n">label_to_root</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
        
        <span class="c1"># Group labels by root</span>
        <span class="n">root_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">filtered_labels</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">label_to_root</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">root_groups</span><span class="p">:</span>
                <span class="n">root_groups</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">root_groups</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        
        <span class="c1"># Count events per label</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">event_count</span><span class="p">[</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;from_label&#39;</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">event_count</span><span class="p">[</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;to_label&#39;</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Sort groups by the minimum label in the group</span>
        <span class="n">sorted_roots</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">root_groups</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>
        
        <span class="c1"># For each root, arrange labels by event count, with most eventful in the middle</span>
        <span class="n">ordered_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">sorted_roots</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">root_groups</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="c1"># Sort by event count descending</span>
            <span class="n">sorted_labels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">event_count</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Arrange to place highest event count in middle</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sorted_labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
                    <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">ordered_group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="n">ordered_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ordered_group</span><span class="p">)</span>
    
        <span class="c1"># Plot setup (only for filtered labels, ordered)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        
        <span class="c1"># Limit to first 50 entries to keep plot readable</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">:</span>
            <span class="n">ordered_labels</span> <span class="o">=</span> <span class="n">ordered_labels</span><span class="p">[:</span><span class="mi">40</span><span class="p">]</span>
    
        <span class="n">y_positions</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ordered_labels</span><span class="p">)}</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">y_positions</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">y_positions</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time Step&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Watershed Object History: Merges and Splits (Filtered to Event-Involved Labels)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>   <span class="c1"># increase x-axis tick fontsize</span>
    
        <span class="c1"># Plot label lifetimes as horizontal lines (only for filtered labels)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">)</span> <span class="ow">in</span> <span class="n">filtered_label_times</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">y_positions</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y_positions</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
        <span class="c1"># Plot events (only for filtered labels)</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">from_label</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;from_label&#39;</span><span class="p">]</span>
            <span class="n">to_label</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;to_label&#39;</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>
            <span class="n">event_type</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
            
            <span class="c1"># Only plot if both labels are in the filtered set</span>
            <span class="k">if</span> <span class="n">from_label</span> <span class="ow">in</span> <span class="n">y_positions</span> <span class="ow">and</span> <span class="n">to_label</span> <span class="ow">in</span> <span class="n">y_positions</span><span class="p">:</span>
                <span class="n">y_from</span> <span class="o">=</span> <span class="n">y_positions</span><span class="p">[</span><span class="n">from_label</span><span class="p">]</span>
                <span class="n">y_to</span> <span class="o">=</span> <span class="n">y_positions</span><span class="p">[</span><span class="n">to_label</span><span class="p">]</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span> <span class="k">if</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;merge&#39;</span> <span class="k">else</span> <span class="s1">&#39;green&#39;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">y_from</span><span class="p">,</span> <span class="n">y_to</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">y_from</span><span class="p">,</span> <span class="n">y_to</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    
        <span class="c1"># Create proper legend with correct colors</span>
        <span class="n">lifetime_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Lifetime&#39;</span><span class="p">)</span>
        <span class="n">merge_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Merge&#39;</span><span class="p">)</span>
        <span class="n">split_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Split&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">lifetime_patch</span><span class="p">,</span> <span class="n">merge_patch</span><span class="p">,</span> <span class="n">split_patch</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    
        <span class="c1"># save the plot in a pdf</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s1">&#39;outputs&#39;</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;outputs/watershed_history_&#39;</span> <span class="o">+</span> <span class="n">object_type</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">union_array</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">histories</span><span class="p">,</span> <span class="n">history_data</span></div>

    


<span class="c1">#from memory_profiler import profile</span>
<span class="c1"># @profile_</span>
<div class="viewcode-block" id="watershed_2d_overlap">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.watershed_2d_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">watershed_2d_overlap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="c1"># 3D matrix with data for watershedding [np.array]</span>
                         <span class="n">object_threshold</span><span class="p">,</span> <span class="c1"># float to create binary object mast [float]</span>
                         <span class="n">max_treshold</span><span class="p">,</span> <span class="c1"># value for identifying max. points for spreading [float]</span>
                         <span class="n">min_dist</span><span class="p">,</span> <span class="c1"># minimum distance (in grid cells) between maximum points [int]</span>
                         <span class="n">dT</span><span class="p">,</span> <span class="c1"># time interval in hours [int]</span>
                         <span class="n">mintime</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="c1"># minimum time an object has to exist in dT [int]</span>
                         <span class="n">connectLon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># do we have to track features over the date line?</span>
                         <span class="n">extend_size_ratio</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span> <span class="c1"># if connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs</span>
                         <span class="n">erosion_disk</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs watershedding on 2D anomaly fields over time and connects</span>
<span class="sd">    the resulting 2D features into 3D objects based on maximum overlap.</span>
<span class="sd">    This function uses spatially reduced watersheds from the previous time step as seed for the</span>
<span class="sd">    current time step, which improves temporal consistency of features.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        3D array of data for watershedding [time, lat, lon].</span>
<span class="sd">    object_threshold : float</span>
<span class="sd">        Threshold to create binary object mask.</span>
<span class="sd">    max_treshold : float</span>
<span class="sd">        Threshold for identifying maximum points for spreading.</span>
<span class="sd">    min_dist : int</span>
<span class="sd">        Minimum distance (in grid cells) between maximum points.</span>
<span class="sd">    dT : int</span>
<span class="sd">        Time interval in hours.</span>
<span class="sd">    mintime : int, optional</span>
<span class="sd">        Minimum time an object has to exist in dT. Default is 24.</span>
<span class="sd">    connectLon : int, optional</span>
<span class="sd">        Whether to track features over the date line (1 for yes, 0 for no). Default is 0.</span>
<span class="sd">    extend_size_ratio : float, optional</span>
<span class="sd">        If connectLon = 1, this sets the ratio of the zonal domain added to the watershedding.</span>
<span class="sd">        This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs. Default is 0.25.</span>
<span class="sd">    erosion_disk : float, optional</span>
<span class="sd">        Disk size for erosion of previous timestep mask to improve temporal connection of features. Default is 3.5.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">connectLon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">extension_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">extend_size_ratio</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">extension_size</span><span class="p">:],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">extension_size</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
    <span class="n">data_2d_watershed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="n">data_2d_watershed</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">tt</span><span class="p">,:]</span> <span class="o">&gt;=</span> <span class="n">object_threshold</span>
        <span class="n">data_t0</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">tt</span><span class="p">,:,:]</span>

        <span class="c1"># get maximum precipitation over three time steps to make fields more coherant</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">data_t0</span><span class="p">,</span> 
                                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">min_dist</span><span class="p">,</span>
                                <span class="n">threshold_abs</span> <span class="o">=</span> <span class="n">max_treshold</span><span class="p">,</span>
                                <span class="n">labels</span> <span class="o">=</span> <span class="n">image</span>
                               <span class="p">)</span>
    
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_t0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">markers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">tt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># allow markers to change a bit from time to time and </span>
            <span class="c1"># introduce new markers if they have strong enough max/min and</span>
            <span class="c1"># are far enough away from existing objects</span>

            <span class="n">boundaries</span> <span class="o">=</span> <span class="n">find_boundaries</span><span class="p">(</span><span class="n">data_2d_watershed</span><span class="p">[</span><span class="n">tt</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
            <span class="c1"># Set boundaries to zero in the markers</span>
            <span class="n">separated_markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data_2d_watershed</span><span class="p">[</span><span class="n">tt</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
            <span class="n">separated_markers</span><span class="p">[</span><span class="n">boundaries</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">separated_markers</span> <span class="o">=</span> <span class="n">erosion</span><span class="p">(</span><span class="n">separated_markers</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="n">erosion_disk</span><span class="p">))</span> <span class="c1">#3.5</span>
            <span class="n">separated_markers</span><span class="p">[</span><span class="n">data_2d_watershed</span><span class="p">[</span><span class="n">tt</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="c1"># add unique new markers if they are not too close to old objects</span>

            <span class="n">dilated_matrix</span> <span class="o">=</span> <span class="n">dilation</span><span class="p">(</span><span class="n">data_2d_watershed</span><span class="p">[</span><span class="n">tt</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="n">disk</span><span class="p">(</span><span class="mf">2.5</span><span class="p">))</span>
            <span class="n">markers_updated</span> <span class="o">=</span> <span class="p">(</span><span class="n">markers</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">separated_markers</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
            <span class="n">markers_updated</span><span class="p">[</span><span class="n">markers_updated</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">separated_markers</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">markers_add</span> <span class="o">=</span> <span class="p">(</span><span class="n">markers_updated</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dilated_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="n">separated_markers</span><span class="p">[</span><span class="n">markers_add</span><span class="p">]</span> <span class="o">=</span> <span class="n">markers_updated</span><span class="p">[</span><span class="n">markers_add</span><span class="p">]</span>
            <span class="n">markers</span> <span class="o">=</span> <span class="n">separated_markers</span>
            <span class="c1"># break up elements that are no longer connected</span>
            <span class="n">markers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span>
    
            <span class="c1"># make sure that spatially separate objects have unique labels</span>
            <span class="c1"># markers, _ = ndi.label(mask)</span>
        <span class="n">data_2d_watershed</span><span class="p">[</span><span class="n">tt</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">tt</span><span class="p">,:])</span><span class="o">*-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># watershedding field with maxima transformed to minima</span>
                        <span class="n">markers</span> <span class="o">=</span> <span class="n">markers</span><span class="p">,</span> <span class="c1"># maximum points in 3D matrix</span>
                        <span class="n">connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="c1"># connectivity</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span> <span class="c1">#4000/dx_m[dx]).astype(&#39;int&#39;),</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">image</span><span class="p">,</span> <span class="c1"># binary mask for areas to watershed on</span>
                        <span class="n">compactness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># high values --&gt; more regular shaped watersheds</span>
    
    <span class="k">if</span> <span class="n">connectLon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Crop to the original size</span>
        <span class="c1"># start = extension_size</span>
        <span class="c1"># end = start + image.shape[axis]</span>
        <span class="k">if</span> <span class="n">extension_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data_2d_watershed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_2d_watershed</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">extension_size</span><span class="p">:</span><span class="o">-</span><span class="n">extension_size</span><span class="p">])</span>
        <span class="n">data_2d_watershed</span> <span class="o">=</span> <span class="n">ConnectLon_on_timestep</span><span class="p">(</span><span class="n">data_2d_watershed</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>

    <span class="c1">### CONNECT OBJECTS IN 3D BASED ON MAX OVERLAP</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_2d_watershed</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">connect_3d_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> 
                                 <span class="nb">int</span><span class="p">(</span><span class="n">mintime</span><span class="o">/</span><span class="n">dT</span><span class="p">),</span> 
                                 <span class="n">dT</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">objects</span></div>



<span class="c1"># from memory_profiler import profile</span>
<span class="c1"># # @profile__sections</span>
<span class="c1"># @profile_</span>
<div class="viewcode-block" id="watershed_3d_overlap">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.watershed_3d_overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">watershed_3d_overlap</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">object_threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">max_treshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">min_dist</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dT</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mintime</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
    <span class="n">connectLon</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">extend_size_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform 3D watershedding on the input data with temporal consistency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        3D matrix with data for watershedding</span>
<span class="sd">    object_threshold : float</span>
<span class="sd">        Float to create binary object mast</span>
<span class="sd">    max_treshold : float</span>
<span class="sd">        Value for identifying max. points for spreading</span>
<span class="sd">    min_dist : int</span>
<span class="sd">        Minimum distance (in grid cells) between maximum points</span>
<span class="sd">    dT : int</span>
<span class="sd">        Time interval in hours</span>
<span class="sd">    mintime : int, optional</span>
<span class="sd">        Minimum time an object has to exist in dT, by default 24</span>
<span class="sd">    connectLon : int, optional</span>
<span class="sd">        Do we have to track features over the date line?, by default 0</span>
<span class="sd">    extend_size_ratio : float, optional</span>
<span class="sd">        If connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. </span>
<span class="sd">        This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs, by default 0.25</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        3D matrix with watershed labels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">connectLon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">extension_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">extend_size_ratio</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">extension_size</span><span class="p">:],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">extension_size</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">object_threshold</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">object_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">object_threshold</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">extension_size</span><span class="p">:],</span> <span class="n">object_threshold</span><span class="p">,</span> <span class="n">object_threshold</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">extension_size</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
            <span class="p">)</span>
    
    <span class="c1"># Create a binary mask for watershedding, all data that needs to be segmented is True</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;=</span> <span class="n">object_threshold</span>
    
    <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># find peaks in each time slice and add time as an additional coordinate</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">coords_t</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> 
                                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">min_dist</span><span class="p">,</span>
                                <span class="n">threshold_abs</span> <span class="o">=</span> <span class="n">max_treshold</span><span class="p">,</span>
                                <span class="n">labels</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                                <span class="n">exclude_border</span><span class="o">=</span><span class="kc">True</span>
                               <span class="p">)</span>

        <span class="n">coords_with_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">coords_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">),</span> <span class="n">coords_t</span><span class="p">))</span>
        <span class="n">coords_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_with_time</span><span class="p">)</span>

    <span class="c1"># Combine all coordinates into a single array</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">coords_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># label peaks over time to ensure temporal consistency</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">label_peaks_over_time_3d</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">)</span>
    <span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">markers</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="n">labels</span>


    <span class="c1"># define connectivity for 3D watershedding and perform watershedding</span>
    <span class="n">conection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">watershed_results</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># watershedding field with maxima transformed to minima</span>
                    <span class="n">markers</span> <span class="o">=</span> <span class="n">markers</span><span class="p">,</span> <span class="c1"># maximum points in 3D matrix</span>
                    <span class="n">connectivity</span> <span class="o">=</span> <span class="n">conection</span><span class="p">,</span> <span class="c1"># connectivity</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span> <span class="c1">#4000/dx_m[dx]).astype(&#39;int&#39;),</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">image</span><span class="p">,</span> <span class="c1"># binary mask for areas to watershed on</span>
                    <span class="n">compactness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># high values --&gt; more regular shaped watersheds</span>

    <span class="c1"># correct objects on date line if needed</span>
    <span class="k">if</span> <span class="n">connectLon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">extension_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">watershed_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">watershed_results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">extension_size</span><span class="p">:</span><span class="o">-</span><span class="n">extension_size</span><span class="p">])</span>
        <span class="n">watershed_results</span> <span class="o">=</span> <span class="n">ConnectLon_on_timestep</span><span class="p">(</span><span class="n">watershed_results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>


    <span class="k">return</span> <span class="n">watershed_results</span></div>


<div class="viewcode-block" id="watershed_3d_overlap_parallel">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.watershed_3d_overlap_parallel">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">watershed_3d_overlap_parallel</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">object_threshold</span><span class="p">,</span>
    <span class="n">max_treshold</span><span class="p">,</span>
    <span class="n">min_dist</span><span class="p">,</span>
    <span class="n">dT</span><span class="p">,</span>
    <span class="n">mintime</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
    <span class="n">connectLon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">extend_size_ratio</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">n_chunks_lat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">n_chunks_lon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">overlap_cells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mp_method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parallel version of watershed_3d_overlap using domain decomposition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        3D matrix with data for watershedding</span>
<span class="sd">    object_threshold : float</span>
<span class="sd">        Float to create binary object mask</span>
<span class="sd">    max_treshold : float</span>
<span class="sd">        Value for identifying max. points for spreading</span>
<span class="sd">    min_dist : int</span>
<span class="sd">        Minimum distance (in grid cells) between maximum points</span>
<span class="sd">    dT : int</span>
<span class="sd">        Time interval in hours</span>
<span class="sd">    mintime : int, optional</span>
<span class="sd">        Minimum time an object has to exist in dT, by default 24</span>
<span class="sd">    connectLon : int, optional</span>
<span class="sd">        Do we have to track features over the date line?, by default 0</span>
<span class="sd">    extend_size_ratio : float, optional</span>
<span class="sd">        If connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. </span>
<span class="sd">        This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs, by default 0.25</span>
<span class="sd">    n_chunks_lat : int, default=None</span>
<span class="sd">        Number of chunks to split latitude dimension, if None, auto-detects based on CPU count</span>
<span class="sd">    n_chunks_lon : int, default=None</span>
<span class="sd">        Number of chunks to split longitude dimension</span>
<span class="sd">    overlap_cells : int, optional</span>
<span class="sd">        Number of overlapping cells between chunks. If None, uses min_dist * 2</span>
<span class="sd">    mp_method : str, optional</span>
<span class="sd">        Multiprocessing method: &#39;fork&#39;, &#39;spawn&#39;, or &#39;auto&#39; (default). &#39;auto&#39; chooses based on data size and system memory.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        3D matrix with watershed labels</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> 

    <span class="k">if</span> <span class="n">n_chunks_lat</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_chunks_lon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Only one chunk specified, running serial version.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">watershed_3d_overlap</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">object_threshold</span><span class="p">,</span>
            <span class="n">max_treshold</span><span class="p">,</span>
            <span class="n">min_dist</span><span class="p">,</span>
            <span class="n">dT</span><span class="p">,</span>
            <span class="n">mintime</span><span class="p">,</span>
            <span class="n">connectLon</span><span class="p">,</span>
            <span class="n">extend_size_ratio</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">n_chunks_lat</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_chunks_lon</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_proc</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># get one less for system processes</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto-detecting number of processes: </span><span class="si">{</span><span class="n">num_proc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">num_proc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">num_proc</span><span class="p">)</span> <span class="c1"># limit to 16 processes max to avoid oversubscription</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shape of the data to watershed: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">lon</span><span class="o">/</span><span class="n">lat</span>
        <span class="n">n_chunks_lon</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_proc</span> <span class="o">*</span> <span class="n">r</span><span class="p">)))</span>
        <span class="n">n_chunks_lat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_proc</span> <span class="o">/</span> <span class="n">n_chunks_lon</span><span class="p">))</span>
        <span class="c1"># print(n_chunks_lat, n_chunks_lon)</span>
        <span class="k">while</span> <span class="n">n_chunks_lat</span> <span class="o">*</span> <span class="n">n_chunks_lon</span> <span class="o">&gt;</span> <span class="n">num_proc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_chunks_lon</span> <span class="o">&gt;</span> <span class="n">n_chunks_lat</span> <span class="o">*</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">n_chunks_lon</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_chunks_lat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n_chunks_lon</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_chunks_lat</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto-configured to </span><span class="si">{</span><span class="n">n_chunks_lat</span><span class="si">}</span><span class="s2"> latitude chunks and </span><span class="si">{</span><span class="n">n_chunks_lon</span><span class="si">}</span><span class="s2"> longitude chunks for parallel processing.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Set default overlap</span>
    <span class="k">if</span> <span class="n">overlap_cells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlap_cells</span> <span class="o">=</span> <span class="n">min_dist</span> <span class="o">*</span> <span class="mi">4</span>
    
    <span class="c1"># Handle dateline extension</span>
    <span class="k">if</span> <span class="n">connectLon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">extension_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">extend_size_ratio</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">extension_size</span><span class="p">:],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">extension_size</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extension_size</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">nt</span><span class="p">,</span> <span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c1"># --- SETUP SHARED MEMORY FOR INPUT &amp; MAIN OUTPUT ---</span>
    <span class="n">shm_input</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)</span>
    <span class="n">shared_input_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm_input</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
    <span class="n">shared_input_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>
    
    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span> 
    <span class="n">out_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
    <span class="n">shm_output</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">out_size</span><span class="p">)</span>
    <span class="n">shared_output_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm_output</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
    <span class="n">shared_output_arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 

    <span class="c1"># --- PRE-CALCULATE HALO BUFFER SIZE ---</span>
    <span class="c1"># We need to store the &quot;Upper&quot; halos for Lat and Lon for every chunk.</span>
    <span class="c1"># To do this efficiently, we pre-calculate the boundaries and required size.</span>
    <span class="n">lat_chunks</span> <span class="o">=</span> <span class="n">_calculate_chunk_boundaries</span><span class="p">(</span><span class="n">nlat</span><span class="p">,</span> <span class="n">n_chunks_lat</span><span class="p">,</span> <span class="n">overlap_cells</span><span class="p">)</span>
    <span class="n">lon_chunks</span> <span class="o">=</span> <span class="n">_calculate_chunk_boundaries</span><span class="p">(</span><span class="n">nlon</span><span class="p">,</span> <span class="n">n_chunks_lon</span><span class="p">,</span> <span class="n">overlap_cells</span><span class="p">)</span>
    
    <span class="n">halo_metadata</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Stores size and offset info for each chunk</span>
    <span class="n">total_halo_elements</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lat_s</span><span class="p">,</span> <span class="n">lat_e</span><span class="p">,</span> <span class="n">lat_cs</span><span class="p">,</span> <span class="n">lat_ce</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lat_chunks</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">lon_s</span><span class="p">,</span> <span class="n">lon_e</span><span class="p">,</span> <span class="n">lon_cs</span><span class="p">,</span> <span class="n">lon_ce</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lon_chunks</span><span class="p">):</span>
            <span class="c1"># Calculate dimensions of the halos this chunk will produce</span>
            <span class="c1"># Note: Halos are the regions OUTSIDE the core but INSIDE the chunk</span>
            
            <span class="c1"># Lat Halo Upper (South side of chunk): Shape (T, overlap_lat, width_lon)</span>
            <span class="c1"># We strictly clip the halo width to the CORE width to match the neighbor&#39;s core</span>
            <span class="n">h_lat_h</span> <span class="o">=</span> <span class="n">lat_e</span> <span class="o">-</span> <span class="n">lat_ce</span>
            <span class="n">h_lat_w</span> <span class="o">=</span> <span class="n">lon_ce</span> <span class="o">-</span> <span class="n">lon_cs</span> <span class="c1"># Core width only </span>
            <span class="n">size_lat</span> <span class="o">=</span> <span class="n">nt</span> <span class="o">*</span> <span class="n">h_lat_h</span> <span class="o">*</span> <span class="n">h_lat_w</span>
            
            <span class="c1"># Lon Halo Upper (East side of chunk): Shape (T, width_lat, overlap_lon)</span>
            <span class="n">h_lon_h</span> <span class="o">=</span> <span class="n">lat_ce</span> <span class="o">-</span> <span class="n">lat_cs</span>
            <span class="n">h_lon_w</span> <span class="o">=</span> <span class="n">lon_e</span> <span class="o">-</span> <span class="n">lon_ce</span>
            <span class="n">size_lon</span> <span class="o">=</span> <span class="n">nt</span> <span class="o">*</span> <span class="n">h_lon_h</span> <span class="o">*</span> <span class="n">h_lon_w</span>
            
            <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;chunk_i&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;chunk_j&#39;</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span>
                <span class="s1">&#39;lat_bounds&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">lat_s</span><span class="p">,</span> <span class="n">lat_e</span><span class="p">,</span> <span class="n">lat_cs</span><span class="p">,</span> <span class="n">lat_ce</span><span class="p">),</span>
                <span class="s1">&#39;lon_bounds&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">lon_s</span><span class="p">,</span> <span class="n">lon_e</span><span class="p">,</span> <span class="n">lon_cs</span><span class="p">,</span> <span class="n">lon_ce</span><span class="p">),</span>
                <span class="s1">&#39;lat_halo_shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">h_lat_h</span><span class="p">,</span> <span class="n">h_lat_w</span><span class="p">),</span>
                <span class="s1">&#39;lon_halo_shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">h_lon_h</span><span class="p">,</span> <span class="n">h_lon_w</span><span class="p">),</span>
                <span class="s1">&#39;lat_halo_offset&#39;</span><span class="p">:</span> <span class="n">total_halo_elements</span><span class="p">,</span>
                <span class="s1">&#39;lon_halo_offset&#39;</span><span class="p">:</span> <span class="n">total_halo_elements</span> <span class="o">+</span> <span class="n">size_lat</span>
            <span class="p">}</span>
            <span class="n">halo_metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>
            <span class="n">total_halo_elements</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size_lat</span> <span class="o">+</span> <span class="n">size_lon</span><span class="p">)</span>

    <span class="c1"># --- SETUP SHARED MEMORY FOR HALOS ---</span>
    <span class="n">halo_bytes</span> <span class="o">=</span> <span class="n">total_halo_elements</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
    <span class="n">shm_halos</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">halo_bytes</span><span class="p">)</span>
    <span class="c1"># We don&#39;t create a single NDArray here because it&#39;s a flat buffer containing many arrays</span>

    <span class="c1"># --- DECISION LOGIC (The &quot;Smart Switch&quot;) ---</span>
    <span class="c1"># This block decides the strategy if &#39;auto&#39; is selected.</span>
    <span class="k">if</span> <span class="n">mp_method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">total_cells</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># Example thresholds (to be calibrated):</span>
        <span class="n">FORK_LIMIT</span> <span class="o">=</span> <span class="mi">600000000</span>     <span class="c1"># Below 600M cells -&gt; Parallel (Fork)</span>
                                   <span class="c1"># Above -&gt; Parallel (Spawn)</span>
        
        <span class="k">if</span> <span class="n">total_cells</span> <span class="o">&lt;</span> <span class="n">FORK_LIMIT</span><span class="p">:</span>
            <span class="n">mp_method</span> <span class="o">=</span> <span class="s1">&#39;fork&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mp_method</span> <span class="o">=</span> <span class="s1">&#39;spawn&#39;</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Processing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">halo_metadata</span><span class="p">)</span><span class="si">}</span><span class="s2"> chunks with </span><span class="si">{</span><span class="n">halo_bytes</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1e9</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> GB halo buffer...&quot;</span><span class="p">)</span>
        
        <span class="n">chunk_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">halo_metadata</span><span class="p">:</span>
            <span class="n">chunk_args</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="n">meta</span><span class="p">,</span>
                <span class="n">shm_input</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">shm_output</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">shm_halos</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">out_dtype</span><span class="p">,</span>
                <span class="n">object_threshold</span><span class="p">,</span>
                <span class="n">max_treshold</span><span class="p">,</span>
                <span class="n">min_dist</span>
            <span class="p">))</span>
        
        <span class="c1"># --- RUN PARALLEL ---</span>
        <span class="c1"># Modified to use the selected method</span>
        <span class="k">if</span> <span class="n">mp_method</span> <span class="o">==</span> <span class="s1">&#39;spawn&#39;</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
            <span class="n">PoolClass</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Pool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default to &#39;fork&#39; (standard mp.Pool)</span>
            <span class="c1"># WARNING: &#39;fork&#39; can deadlock with C-libs, but is faster for medium data</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;fork&#39;</span><span class="p">)</span>
            <span class="n">PoolClass</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Pool</span>

        <span class="k">with</span> <span class="n">PoolClass</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">worker_results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">_process_watershed_chunk_no_return</span><span class="p">,</span> <span class="n">chunk_args</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Merging chunk results...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Combine the worker results (metadata) with the pre-calculated halo metadata</span>
        <span class="c1"># We need both to find the data in shared memory</span>
        <span class="n">full_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">w_res</span><span class="p">,</span> <span class="n">h_meta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">worker_results</span><span class="p">,</span> <span class="n">halo_metadata</span><span class="p">):</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">w_res</span><span class="p">,</span> <span class="o">**</span><span class="n">h_meta</span><span class="p">}</span>
            <span class="n">full_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>

        <span class="n">_merge_watershed_chunks</span><span class="p">(</span>
            <span class="n">full_results</span><span class="p">,</span>
            <span class="n">shared_output_arr</span><span class="p">,</span> 
            <span class="n">shm_halos</span><span class="p">,</span>         
            <span class="n">lat_chunks</span><span class="p">,</span>
            <span class="n">lon_chunks</span>
        <span class="p">)</span>
        <span class="n">final_result</span> <span class="o">=</span> <span class="n">_relabel_consecutive</span><span class="p">(</span><span class="n">shared_output_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># CLEANUP</span>
        <span class="n">shm_input</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">shm_input</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="n">shm_output</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">shm_output</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="n">shm_halos</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">shm_halos</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">connectLon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">extension_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">final_result</span> <span class="o">=</span> <span class="n">final_result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">extension_size</span><span class="p">:</span><span class="o">-</span><span class="n">extension_size</span><span class="p">]</span>
        <span class="n">final_result</span> <span class="o">=</span> <span class="n">ConnectLon_on_timestep</span><span class="p">(</span><span class="n">final_result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">final_result</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_relabel_consecutive</span><span class="p">(</span><span class="n">labeled_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relabel array to have consecutive integer labels starting from 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labeled_array : np.ndarray</span>
<span class="sd">        3D array of labeled data with not necessarily consecutive integers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Relabeled array with consecutive integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get unique non-zero labels</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_array</span><span class="p">[</span><span class="n">labeled_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">labeled_array</span>
    
    <span class="c1"># Create a lookup array: old_label -&gt; new_label</span>
    <span class="c1"># The maximum old label determines the size we need</span>
    <span class="n">max_label</span> <span class="o">=</span> <span class="n">unique_labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># unique_labels is sorted</span>
    <span class="n">lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_label</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">labeled_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">lookup</span><span class="p">[</span><span class="n">unique_labels</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">labeled_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
    <span class="c1"># Apply the mapping using fancy indexing</span>
    <span class="c1"># This is MUCH faster than looping</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">labeled_array</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_process_watershed_chunk_no_return</span><span class="p">(</span>
    <span class="n">meta</span><span class="p">,</span>
    <span class="n">shm_input_name</span><span class="p">,</span>      
    <span class="n">shm_output_name</span><span class="p">,</span>
    <span class="n">shm_halos_name</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">,</span>         
    <span class="n">dtype_in</span><span class="p">,</span>
    <span class="n">dtype_out</span><span class="p">,</span>       
    <span class="n">object_threshold</span><span class="p">,</span>
    <span class="n">max_treshold</span><span class="p">,</span>
    <span class="n">min_dist</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a single watershed chunk in shared memory without returning large arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    meta : Dict</span>
<span class="sd">        Metadata for the chunk (boundaries, halo shapes, offsets).</span>
<span class="sd">    shm_input_name : str</span>
<span class="sd">        Name of the shared memory for input data.</span>
<span class="sd">    shm_output_name : str</span>
<span class="sd">        Name of the shared memory for output data.</span>
<span class="sd">    shm_halos_name : str</span>
<span class="sd">        Name of the shared memory for halo data.</span>
<span class="sd">    shape : Tuple[int]</span>
<span class="sd">        Shape of the full data array.</span>
<span class="sd">    dtype_in : np.dtype</span>
<span class="sd">        Data type of the input data.</span>
<span class="sd">    dtype_out : np.dtype</span>
<span class="sd">        Data type of the output data.</span>
<span class="sd">    object_threshold : float</span>
<span class="sd">        Threshold to create binary object mask.</span>
<span class="sd">    max_treshold : float</span>
<span class="sd">        Threshold for identifying maximum points for spreading.</span>
<span class="sd">    min_dist : int</span>
<span class="sd">        Minimum distance (in grid cells) between maximum points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict</span>
<span class="sd">        max_label : int</span>
<span class="sd">            Maximum label found in this chunk.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Attach to shared memories</span>
    <span class="n">shm_in</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">shm_input_name</span><span class="p">)</span>
    <span class="n">shm_out</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">shm_output_name</span><span class="p">)</span>
    <span class="n">shm_halos</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">shm_halos_name</span><span class="p">)</span>
    
    <span class="n">full_data_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_in</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm_in</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
    <span class="n">full_data_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_out</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm_out</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
    
    <span class="c1"># Create flat wrapper for halo buffer</span>
    <span class="c1"># We will reconstruct the specific halo arrays using slicing</span>
    <span class="n">flat_halos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">shm_halos</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype_out</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,),</span> 
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_out</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm_halos</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
    
    <span class="n">lat_s</span><span class="p">,</span> <span class="n">lat_e</span><span class="p">,</span> <span class="n">lat_cs</span><span class="p">,</span> <span class="n">lat_ce</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">]</span>
    <span class="n">lon_s</span><span class="p">,</span> <span class="n">lon_e</span><span class="p">,</span> <span class="n">lon_cs</span><span class="p">,</span> <span class="n">lon_ce</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">]</span>
    
    <span class="n">chunk_data</span> <span class="o">=</span> <span class="n">full_data_in</span><span class="p">[:,</span> <span class="n">lat_s</span><span class="p">:</span><span class="n">lat_e</span><span class="p">,</span> <span class="n">lon_s</span><span class="p">:</span><span class="n">lon_e</span><span class="p">]</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># --- Perform Watershed (Same as before) ---</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">chunk_data</span> <span class="o">&gt;=</span> <span class="n">object_threshold</span>
        
        <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chunk_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">coords_t</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span>
                <span class="n">chunk_data</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
                <span class="n">threshold_abs</span><span class="o">=</span><span class="n">max_treshold</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">image</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                <span class="n">exclude_border</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">coords_t</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coords_with_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">coords_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">),</span> <span class="n">coords_t</span><span class="p">))</span>
                <span class="n">coords_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_with_time</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">coords_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">chunk_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
            
        <span class="n">labels</span> <span class="o">=</span> <span class="n">label_peaks_over_time_3d</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">)</span>
        <span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">chunk_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">markers</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="n">labels</span>
            
        <span class="n">watershed_result</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span>
            <span class="n">image</span><span class="o">=</span><span class="n">chunk_data</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">markers</span><span class="o">=</span><span class="n">markers</span><span class="p">,</span>
            <span class="n">connectivity</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
            <span class="n">compactness</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="c1"># -------------------------------------------</span>

        <span class="n">rel_lat_cs</span> <span class="o">=</span> <span class="n">lat_cs</span> <span class="o">-</span> <span class="n">lat_s</span>
        <span class="n">rel_lat_ce</span> <span class="o">=</span> <span class="n">lat_ce</span> <span class="o">-</span> <span class="n">lat_s</span>
        <span class="n">rel_lon_cs</span> <span class="o">=</span> <span class="n">lon_cs</span> <span class="o">-</span> <span class="n">lon_s</span>
        <span class="n">rel_lon_ce</span> <span class="o">=</span> <span class="n">lon_ce</span> <span class="o">-</span> <span class="n">lon_s</span>

        <span class="n">core_result</span> <span class="o">=</span> <span class="n">watershed_result</span><span class="p">[:,</span> <span class="n">rel_lat_cs</span><span class="p">:</span><span class="n">rel_lat_ce</span><span class="p">,</span> <span class="n">rel_lon_cs</span><span class="p">:</span><span class="n">rel_lon_ce</span><span class="p">]</span>
        <span class="n">full_data_out</span><span class="p">[:,</span> <span class="n">lat_cs</span><span class="p">:</span><span class="n">lat_ce</span><span class="p">,</span> <span class="n">lon_cs</span><span class="p">:</span><span class="n">lon_ce</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_out</span><span class="p">)</span>

        <span class="c1"># Extract Halo slices from local result</span>
        <span class="c1"># Lat Halo (Upper)</span>
        <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;lat_halo_shape&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We crop the halo to the CORE width (rel_lon_cs to rel_lon_ce)</span>
            <span class="c1"># to align spatially with the neighbor&#39;s core</span>
            <span class="n">h_lat</span> <span class="o">=</span> <span class="n">watershed_result</span><span class="p">[:,</span> <span class="n">rel_lat_ce</span><span class="p">:,</span> <span class="n">rel_lon_cs</span><span class="p">:</span><span class="n">rel_lon_ce</span><span class="p">]</span> 
            <span class="c1"># Flatten and write to buffer</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;lat_halo_offset&#39;</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">h_lat</span><span class="o">.</span><span class="n">size</span>
            <span class="n">flat_halos</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">h_lat</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_out</span><span class="p">)</span>

        <span class="c1"># Lon Halo (Upper)</span>
        <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;lon_halo_shape&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Crop to CORE height (rel_lat_cs to rel_lat_ce)</span>
            <span class="n">h_lon</span> <span class="o">=</span> <span class="n">watershed_result</span><span class="p">[:,</span> <span class="n">rel_lat_cs</span><span class="p">:</span><span class="n">rel_lat_ce</span><span class="p">,</span> <span class="n">rel_lon_ce</span><span class="p">:]</span> 
            <span class="n">start</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;lon_halo_offset&#39;</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">h_lon</span><span class="o">.</span><span class="n">size</span>
            <span class="n">flat_halos</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">h_lon</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_out</span><span class="p">)</span>

        <span class="c1"># Return only tiny metadata</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;max_label&#39;</span><span class="p">:</span> <span class="n">watershed_result</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">watershed_result</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">}</span>
        
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">shm_in</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">shm_out</span><span class="o">.</span><span class="n">close</span><span class="p">();</span> <span class="n">shm_halos</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_merge_watershed_chunks</span><span class="p">(</span><span class="n">chunk_results</span><span class="p">,</span> <span class="n">merged_array</span><span class="p">,</span> <span class="n">shm_halos</span><span class="p">,</span> <span class="n">lat_chunks</span><span class="p">,</span> <span class="n">lon_chunks</span><span class="p">):</span>
    <span class="c1"># Reconstruct the flat halo array</span>
    <span class="n">dtype_out</span> <span class="o">=</span> <span class="n">merged_array</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">flat_halos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">shm_halos</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype_out</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,),</span> 
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_out</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm_halos</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>

    <span class="n">chunk_results</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;chunk_i&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;chunk_j&#39;</span><span class="p">]))</span>
    
    <span class="c1"># Calculate Offsets</span>
    <span class="n">chunk_offsets</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">current_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">chunk_results</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;chunk_i&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;chunk_j&#39;</span><span class="p">])</span>
        <span class="n">chunk_offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_offset</span>
        <span class="n">current_offset</span> <span class="o">+=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;max_label&#39;</span><span class="p">]</span>
    
    <span class="n">total_max_label</span> <span class="o">=</span> <span class="n">current_offset</span>

    <span class="c1"># Build Merge Map</span>
    <span class="n">global_map</span> <span class="o">=</span> <span class="n">_build_merge_map_shm</span><span class="p">(</span>
        <span class="n">merged_array</span><span class="p">,</span> 
        <span class="n">flat_halos</span><span class="p">,</span>   <span class="c1"># Pass flat buffer</span>
        <span class="n">chunk_results</span><span class="p">,</span> 
        <span class="n">chunk_offsets</span><span class="p">,</span> 
        <span class="n">total_max_label</span>
    <span class="p">)</span>

    <span class="c1"># Apply Map In-Place</span>
    <span class="n">_apply_map_inplace</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">chunk_results</span><span class="p">,</span> <span class="n">chunk_offsets</span><span class="p">,</span> <span class="n">global_map</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_array</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_build_merge_map_shm</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">flat_halos</span><span class="p">,</span> <span class="n">chunk_results</span><span class="p">,</span> <span class="n">chunk_offsets</span><span class="p">,</span> <span class="n">total_max_label</span><span class="p">,</span> <span class="n">overlap_match_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a merge map for watershed labels across chunk boundaries using shared memory halos. This is done using union-find on the lablels </span>
<span class="sd">    of the halo and its neighboring core region.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    merged_array : np.ndarray</span>
<span class="sd">        The full merged watershed array from all chunks.</span>
<span class="sd">    flat_halos : np.ndarray</span>
<span class="sd">        Flat array containing all halo data from chunks.</span>
<span class="sd">    chunk_results : list of dict</span>
<span class="sd">        Metadata for each chunk including halo offsets and shapes.</span>
<span class="sd">    chunk_offsets : dict</span>
<span class="sd">        Offsets for each chunk&#39;s labels in the global label space.</span>
<span class="sd">    total_max_label : int</span>
<span class="sd">        Total number of unique labels across all chunks.</span>
<span class="sd">    overlap_match_threshold : float, optional</span>
<span class="sd">        Threshold for considering a halo-core overlap as a match, by default 0.5.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list mapping each label to its root label after merging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_max_label</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="k">return</span> <span class="n">i</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">parent</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">root_i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">root_j</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root_i</span> <span class="o">!=</span> <span class="n">root_j</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">root_i</span> <span class="o">&lt;</span> <span class="n">root_j</span><span class="p">:</span> <span class="n">parent</span><span class="p">[</span><span class="n">root_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_i</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">parent</span><span class="p">[</span><span class="n">root_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_j</span>

    <span class="n">grid_map</span> <span class="o">=</span> <span class="p">{(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;chunk_i&#39;</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;chunk_j&#39;</span><span class="p">]):</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">chunk_results</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_overlap</span><span class="p">(</span><span class="n">halo_flat_slice</span><span class="p">,</span> <span class="n">halo_shape</span><span class="p">,</span> <span class="n">core_slice_raw</span><span class="p">,</span> <span class="n">offset_halo</span><span class="p">,</span> <span class="n">offset_core</span><span class="p">):</span>
        <span class="c1"># Reshape the flat halo slice back to 3D</span>
        <span class="n">halo_data</span> <span class="o">=</span> <span class="n">halo_flat_slice</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">halo_shape</span><span class="p">)</span>
        
        <span class="c1"># Determine the common shape</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">core_slice_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">core_slice_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">core_slice_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>

        <span class="c1"># Slice both arrays to this common shape</span>
        <span class="n">h_cut</span> <span class="o">=</span> <span class="n">halo_data</span><span class="p">[:</span><span class="n">d0</span><span class="p">,</span> <span class="p">:</span><span class="n">d1</span><span class="p">,</span> <span class="p">:</span><span class="n">d2</span><span class="p">]</span>
        <span class="n">c_cut</span> <span class="o">=</span> <span class="n">core_slice_raw</span><span class="p">[:</span><span class="n">d0</span><span class="p">,</span> <span class="p">:</span><span class="n">d1</span><span class="p">,</span> <span class="p">:</span><span class="n">d2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">d0</span> <span class="o">&lt;</span> <span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">d1</span> <span class="o">&lt;</span> <span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Clipping Halo overlap from </span><span class="si">{</span><span class="n">halo_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Determine the full area of halo objects within this specific window</span>
        <span class="n">mask_halo_only</span> <span class="o">=</span> <span class="n">h_cut</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_halo_only</span><span class="p">):</span> <span class="k">return</span>

        <span class="c1"># Get local IDs + Offset for the Halo objects in this window</span>
        <span class="n">halo_ids_all</span> <span class="o">=</span> <span class="n">h_cut</span><span class="p">[</span><span class="n">mask_halo_only</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset_halo</span>
        
        <span class="c1"># Count total pixels for each halo object in this window</span>
        <span class="c1"># Use simple bincount. IDs are shifted by offset, so we need a large enough bin.</span>
        <span class="k">if</span> <span class="n">halo_ids_all</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_id</span> <span class="o">=</span> <span class="n">halo_ids_all</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">halo_total_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">halo_ids_all</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">max_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Determine Intersections</span>
        <span class="n">mask_intersect</span> <span class="o">=</span> <span class="n">mask_halo_only</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">c_cut</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_intersect</span><span class="p">):</span> <span class="k">return</span>

        <span class="n">halo_ids_int</span> <span class="o">=</span> <span class="n">h_cut</span><span class="p">[</span><span class="n">mask_intersect</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset_halo</span>
        <span class="n">core_ids_int</span> <span class="o">=</span> <span class="n">c_cut</span><span class="p">[</span><span class="n">mask_intersect</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset_core</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">halo_ids_int</span><span class="p">,</span> <span class="n">core_ids_int</span><span class="p">))</span>
        <span class="n">unique_pairs</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">h_id</span><span class="p">,</span> <span class="n">c_id</span><span class="p">),</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_pairs</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
            <span class="c1"># Criterion:</span>
            <span class="c1"># Does the halo object map significantly to the core object?</span>
            <span class="c1"># Ratio = (Intersection Area) / (Halo Object Area in Overlap Window)</span>
            
            <span class="c1"># Now we use the correct total count from the window analysis</span>
            <span class="k">if</span> <span class="n">h_id</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">halo_total_counts</span><span class="p">):</span>
                <span class="n">total_halo_pixels</span> <span class="o">=</span> <span class="n">halo_total_counts</span><span class="p">[</span><span class="n">h_id</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">total_halo_pixels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">total_halo_pixels</span>
                    
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">overlap_match_threshold</span><span class="p">:</span>

                        <span class="n">union</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">h_id</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_id</span><span class="p">))</span>

    <span class="c1"># --- Process Boundaries ---</span>
    <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">chunk_results</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;chunk_i&#39;</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;chunk_j&#39;</span><span class="p">]</span>
        
        <span class="c1"># Check North Neighbor (i+1)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grid_map</span><span class="p">:</span>
            <span class="c1"># Reconstruct Halo from buffer</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lat_halo_shape&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># If height &gt; 0</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lat_halo_offset&#39;</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">halo_view</span> <span class="o">=</span> <span class="n">flat_halos</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                
                <span class="n">neighbor_res</span> <span class="o">=</span> <span class="n">grid_map</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
                
                <span class="c1"># We expect the halo to overlap with the neighbor&#39;s lat_core region</span>
                <span class="c1"># specifically the *start* of the neighbor&#39;s core.</span>
                <span class="n">neighbor_lat_start</span> <span class="o">=</span> <span class="n">neighbor_res</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># lat_core_start</span>
                <span class="n">neighbor_lat_end</span> <span class="o">=</span> <span class="n">neighbor_res</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>   <span class="c1"># lat_core_end</span>
                
                <span class="c1"># The theoretical overlap height is shape[1]</span>
                <span class="c1"># But we can&#39;t go beyond the neighbor&#39;s core size</span>
                <span class="n">max_h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">neighbor_lat_end</span> <span class="o">-</span> <span class="n">neighbor_lat_start</span><span class="p">)</span>
                
                <span class="n">core_slice</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span>
                    <span class="p">:,</span> 
                    <span class="n">neighbor_lat_start</span> <span class="p">:</span> <span class="n">neighbor_lat_start</span> <span class="o">+</span> <span class="n">max_h</span><span class="p">,</span> 
                    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># Match my core width</span>
                <span class="p">]</span>
                
                <span class="n">check_overlap</span><span class="p">(</span><span class="n">halo_view</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">core_slice</span><span class="p">,</span> <span class="n">chunk_offsets</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)],</span> <span class="n">chunk_offsets</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)])</span>

        <span class="c1"># Check East Neighbor (j+1)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grid_map</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lon_halo_shape&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lon_halo_offset&#39;</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">halo_view</span> <span class="o">=</span> <span class="n">flat_halos</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                
                <span class="n">neighbor_res</span> <span class="o">=</span> <span class="n">grid_map</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">neighbor_lon_start</span> <span class="o">=</span> <span class="n">neighbor_res</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># lon_core_start</span>
                <span class="n">neighbor_lon_end</span> <span class="o">=</span> <span class="n">neighbor_res</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>   <span class="c1"># lon_core_end</span>
                
                <span class="n">max_w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">neighbor_lon_end</span> <span class="o">-</span> <span class="n">neighbor_lon_start</span><span class="p">)</span>
                
                <span class="n">core_slice</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span>
                    <span class="p">:,</span> 
                    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="c1"># Match my core height</span>
                    <span class="n">neighbor_lon_start</span> <span class="p">:</span> <span class="n">neighbor_lon_start</span> <span class="o">+</span> <span class="n">max_w</span>
                <span class="p">]</span>
                
                <span class="n">check_overlap</span><span class="p">(</span><span class="n">halo_view</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">core_slice</span><span class="p">,</span> <span class="n">chunk_offsets</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)],</span> <span class="n">chunk_offsets</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

    <span class="c1"># --- Build Final Consecutive Map (Same as before) ---</span>
    <span class="n">final_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">total_max_label</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)):</span> <span class="n">final_mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">final_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">unique_roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">final_mapping</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unique_roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">unique_roots</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        
    <span class="n">compress_lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">final_mapping</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">compress_lut</span><span class="p">[</span><span class="n">unique_roots</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">compress_lut</span><span class="p">[</span><span class="n">final_mapping</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_calculate_chunk_boundaries</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">n_chunks</span><span class="p">,</span> <span class="n">overlap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate chunk boundaries with overlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    total_size : int</span>
<span class="sd">        Total size of the dimension to be chunked.</span>
<span class="sd">    n_chunks : int</span>
<span class="sd">        Number of chunks to create.</span>
<span class="sd">    overlap : int</span>
<span class="sd">        Number of overlapping cells between chunks.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuples</span>
<span class="sd">        Each tuple contains (start_with_overlap, end_with_overlap, core_start, core_end)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">//</span> <span class="n">n_chunks</span>
    <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">):</span>
        <span class="c1"># Core region (without overlap)</span>
        <span class="n">core_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">chunk_size</span>
        <span class="n">core_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_chunks</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">total_size</span>
        
        <span class="c1"># Extended region (with overlap)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">core_start</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">core_end</span> <span class="o">+</span> <span class="n">overlap</span><span class="p">)</span>
        
        <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">core_start</span><span class="p">,</span> <span class="n">core_end</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">boundaries</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_apply_map_inplace</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">chunk_results</span><span class="p">,</span> <span class="n">chunk_offsets</span><span class="p">,</span> <span class="n">global_map</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the global mapping to the shared array block-by-block.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    merged_array : np.ndarray</span>
<span class="sd">        The shared array containing the merged watershed results.</span>
<span class="sd">    chunk_results : list of dict</span>
<span class="sd">        Metadata for each chunk processed.</span>
<span class="sd">    chunk_offsets : dict</span>
<span class="sd">        Offsets for each chunk&#39;s local labels in the global map.</span>
<span class="sd">    global_map : np.ndarray</span>
<span class="sd">        The global mapping array from local to global labels.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Applying labels in-place...&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">chunk_results</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;chunk_i&#39;</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;chunk_j&#39;</span><span class="p">])</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">chunk_offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">max_local_label</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;max_label&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">max_local_label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Create Local Lookup Table</span>
        <span class="c1"># Size = max local label + 1 (to include 0)</span>
        <span class="n">local_lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_local_label</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        
        <span class="c1"># Explicitly keep background 0 -&gt; 0</span>
        <span class="n">local_lut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="n">max_local_label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">max_local_label</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">local_lut</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">global_map</span><span class="p">[</span><span class="n">start_idx</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">]</span>
        
        <span class="c1"># Unpack the bounds from the metadata tuples</span>
        <span class="c1"># lat_bounds = (start, end, core_start, core_end)</span>
        <span class="n">lat_core_start</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lat_core_end</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lat_bounds&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        
        <span class="n">lon_core_start</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lon_core_end</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;lon_bounds&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        
        <span class="c1"># Apply in-place</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> 
            <span class="nb">slice</span><span class="p">(</span><span class="n">lat_core_start</span><span class="p">,</span> <span class="n">lat_core_end</span><span class="p">),</span> 
            <span class="nb">slice</span><span class="p">(</span><span class="n">lon_core_start</span><span class="p">,</span> <span class="n">lon_core_end</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="n">chunk_data</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
        
        <span class="c1"># Advanced indexing: reads chunk_data, looks up values in local_lut, writes back</span>
        <span class="n">chunk_data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">local_lut</span><span class="p">[</span><span class="n">chunk_data</span><span class="p">]</span>


<span class="c1"># @profile_</span>
<div class="viewcode-block" id="label_peaks_over_time_3d">
<a class="viewcode-back" href="../../../modules.html#moaap.utils.segmentation.label_peaks_over_time_3d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">label_peaks_over_time_3d</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Labels peaks in 3D coordinates over time based on spatial proximity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords :</span>
<span class="sd">        np.ndarray of shape (N_peaks, 3), each row is [t, y, x]</span>
<span class="sd">    max_dist :  </span>
<span class="sd">        maximum allowed distance to consider peaks as the same object (in grid units)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labels : </span>
<span class="sd">        np.ndarray of shape (N_peaks,), integer labels for each peak over time</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Split coords by timestep</span>
    <span class="n">timesteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">next_label</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">prev_coords</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">prev_labels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">timesteps</span><span class="p">:</span>
        <span class="n">idx_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coords_t</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx_t</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># [y, x] only</span>
        <span class="n">labels_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coords_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prev_coords</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">prev_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># First timestep: assign new labels</span>
            <span class="n">labels_t</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">next_label</span><span class="p">,</span> <span class="n">next_label</span> <span class="o">+</span> <span class="n">coords_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">next_label</span> <span class="o">+=</span> <span class="n">coords_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Build KDTree for previous peaks</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">prev_coords</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords_t</span><span class="p">):</span>
                <span class="n">dist</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">max_dist</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_dist</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">prev_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">labels_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_label</span>
                    <span class="n">next_label</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">idx_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels_t</span>
        <span class="n">prev_coords</span> <span class="o">=</span> <span class="n">coords_t</span>
        <span class="n">prev_labels</span> <span class="o">=</span> <span class="n">labels_t</span>
    <span class="k">return</span> <span class="n">labels</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Andreas F. Prein, Raphael Graf.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>