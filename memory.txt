 
The provided variables allow tracking the following phenomena
 
|  phenomenon  | tracking |
---------------------------
   Jetstream   |   no
   PSL CY/ACY  |   no
   Z500 CY/ACY |   no
   COLs        |   no
   IVT ARs     |   no
   MS ARs      |   no
   Fronts      |   no
   TCs         |   no
   MCSs        |   yes
   clouds      |   yes
   Equ. Waves  |   no
---------------------------
 
======> 'check if Tb objects qualify as MCS (or selected storm type)
        track  clouds
        8339 cloud object found
        fast way that removes obviously too small objects
        92 cloud object remaining
        break up long living cloud shield objects with watershed that have many elements
Filename: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  4217   1396.0 MiB   1396.0 MiB           1   @profile
  4218                                         def watershed_3d_overlap(data, # 3D matrix with data for watershedding [np.array]
  4219                                                                  object_threshold, # float to create binary object mast [float]
  4220                                                                  max_treshold, # value for identifying max. points for spreading [float]
  4221                                                                  min_dist, # minimum distance (in grid cells) between maximum points [int]
  4222                                                                  dT, # time interval in hours [int]
  4223                                                                  mintime = 24, # minimum time an object has to exist in dT [int]
  4224                                                                  connectLon = 0,  # do we have to track features over the date line?
  4225                                                                  extend_size_ratio = 0.25): # if connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs
  4226                                             
  4227   1396.0 MiB      0.0 MiB           1       from scipy import ndimage as ndi
  4228   1396.1 MiB      0.1 MiB           1       from skimage.feature import peak_local_max
  4229   1400.9 MiB      4.8 MiB           1       from skimage.segmentation import watershed
  4230   1400.9 MiB      0.0 MiB           1       from scipy.ndimage import gaussian_filter
  4231   1400.9 MiB      0.0 MiB           1       from Tracking_Functions import clean_up_objects
  4232   1400.9 MiB      0.0 MiB           1       from Tracking_Functions import ConnectLon_on_timestep
  4233                                         
  4234                                             # Determine if we need to extend the data for date line crossing
  4235   1400.9 MiB      0.0 MiB           1       if connectLon == 1:
  4236   1400.9 MiB      0.0 MiB           1           axis = 2
  4237   1400.9 MiB      0.0 MiB           1           extension_size = int(data.shape[2] * extend_size_ratio)
  4238   1628.9 MiB    228.1 MiB           2           data = np.concatenate(
  4239   1400.9 MiB      0.0 MiB           1                   [data[:, :, -extension_size:], data, data[:, :, :extension_size]], axis=axis
  4240                                                     )
  4241                                             
  4242                                             # Create binary mask for watershedding, all data that needs to be segmented is True
  4243   1628.9 MiB      0.0 MiB           1       image = data >= object_threshold
  4244                                             
  4245   1628.9 MiB      0.0 MiB           1       coords_list = []
  4246                                         
  4247                                             # find peaks in each time slice and add time as an additional coordinate
  4248   1653.8 MiB      0.0 MiB          25       for t in range(data.shape[0]):
  4249   1653.8 MiB     24.8 MiB          48           coords_t = peak_local_max(data[t], 
  4250   1653.8 MiB      0.0 MiB          24                                   min_distance = min_dist,
  4251   1653.8 MiB      0.0 MiB          24                                   threshold_abs = max_treshold,
  4252   1653.8 MiB      0.0 MiB          24                                   labels = image[t],
  4253   1653.8 MiB      0.0 MiB          24                                   exclude_border=True
  4254                                                                        )
  4255                                         
  4256   1653.8 MiB      0.0 MiB          24           coords_with_time = np.column_stack((np.full(coords_t.shape[0], t), coords_t))
  4257   1653.8 MiB      0.0 MiB          24           coords_list.append(coords_with_time)
  4258                                         
  4259                                             # Combine all coordinates into a single array
  4260   1653.8 MiB      0.0 MiB           1       if len(coords_list) > 0:
  4261   1653.8 MiB      0.0 MiB           1           coords = np.vstack(coords_list)
  4262                                             else:
  4263                                                 coords = np.empty((0, 3), dtype=int)
  4264                                         
  4265   1653.8 MiB      0.0 MiB           1       mask = np.zeros(data.shape, dtype=bool)
  4266   1682.1 MiB     28.3 MiB           1       mask[tuple(coords.T)] = True
  4267                                         
  4268                                             # label peaks over time to ensure temporal consistency
  4269   1682.1 MiB      0.0 MiB           1       labels = label_peaks_over_time_3d(coords, max_dist=min_dist)
  4270   1682.1 MiB      0.0 MiB           1       markers = np.zeros(data.shape, dtype=int)
  4271   1884.1 MiB    202.0 MiB           1       markers[tuple(coords.T)] = labels
  4272                                         
  4273                                         
  4274                                             # define connectivity for 3D watershedding and perform watershedding
  4275   1884.1 MiB      0.0 MiB           1       conection = np.ones((3, 3, 3))
  4276   2112.3 MiB    228.1 MiB           2       watershed_results = watershed(image = np.array(data)*-1,  # watershedding field with maxima transformed to minima
  4277   2112.3 MiB      0.0 MiB           1                       markers = markers, # maximum points in 3D matrix
  4278   2112.3 MiB      0.0 MiB           1                       connectivity = conection, # connectivity
  4279   2112.3 MiB      0.0 MiB           1                       offset = (np.ones((3)) * 1).astype('int'), #4000/dx_m[dx]).astype('int'),
  4280   2112.3 MiB      0.0 MiB           1                       mask = image, # binary mask for areas to watershed on
  4281   2112.3 MiB      0.0 MiB           1                       compactness = 0) # high values --> more regular shaped watersheds
  4282                                         
  4283                                             # correct objects on date line if needed
  4284   2112.3 MiB      0.0 MiB           1       if connectLon == 1:
  4285   2112.3 MiB      0.0 MiB           1           if extension_size != 0:
  4286   2074.2 MiB    -38.0 MiB           1               watershed_results = np.array(watershed_results[:, :, extension_size:-extension_size])
  4287   2074.2 MiB      0.0 MiB           1           watershed_results = ConnectLon_on_timestep(watershed_results.astype("int"))
  4288                                         
  4289   2074.2 MiB      0.0 MiB           1       return watershed_results


            Loop over 4280 objects
            Loop over 100 objects
        00:00:18.86
======> 'track high clouds in Tb field by excluding MCS objects
        track  clouds
        break up long living cloud shield objects with wathershedding
Filename: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  4217   1795.8 MiB   1795.8 MiB           1   @profile
  4218                                         def watershed_3d_overlap(data, # 3D matrix with data for watershedding [np.array]
  4219                                                                  object_threshold, # float to create binary object mast [float]
  4220                                                                  max_treshold, # value for identifying max. points for spreading [float]
  4221                                                                  min_dist, # minimum distance (in grid cells) between maximum points [int]
  4222                                                                  dT, # time interval in hours [int]
  4223                                                                  mintime = 24, # minimum time an object has to exist in dT [int]
  4224                                                                  connectLon = 0,  # do we have to track features over the date line?
  4225                                                                  extend_size_ratio = 0.25): # if connectLon = 1 this key is setting the ratio of the zonal domain added to the watershedding. This has to be big for large objects (e.g., ARs) and can be smaller for e.g., MCSs
  4226                                             
  4227   1795.8 MiB      0.0 MiB           1       from scipy import ndimage as ndi
  4228   1795.8 MiB      0.0 MiB           1       from skimage.feature import peak_local_max
  4229   1795.8 MiB      0.0 MiB           1       from skimage.segmentation import watershed
  4230   1795.8 MiB      0.0 MiB           1       from scipy.ndimage import gaussian_filter
  4231   1795.8 MiB      0.0 MiB           1       from Tracking_Functions import clean_up_objects
  4232   1795.8 MiB      0.0 MiB           1       from Tracking_Functions import ConnectLon_on_timestep
  4233                                         
  4234                                             # Determine if we need to extend the data for date line crossing
  4235   1795.8 MiB      0.0 MiB           1       if connectLon == 1:
  4236   1795.8 MiB      0.0 MiB           1           axis = 2
  4237   1795.8 MiB      0.0 MiB           1           extension_size = int(data.shape[2] * extend_size_ratio)
  4238   2023.9 MiB    228.1 MiB           2           data = np.concatenate(
  4239   1795.8 MiB      0.0 MiB           1                   [data[:, :, -extension_size:], data, data[:, :, :extension_size]], axis=axis
  4240                                                     )
  4241                                             
  4242                                             # Create binary mask for watershedding, all data that needs to be segmented is True
  4243   2039.9 MiB     16.1 MiB           1       image = data >= object_threshold
  4244                                             
  4245   2039.9 MiB      0.0 MiB           1       coords_list = []
  4246                                         
  4247                                             # find peaks in each time slice and add time as an additional coordinate
  4248   2052.2 MiB      0.0 MiB          25       for t in range(data.shape[0]):
  4249   2052.2 MiB     12.3 MiB          48           coords_t = peak_local_max(data[t], 
  4250   2052.2 MiB      0.0 MiB          24                                   min_distance = min_dist,
  4251   2052.2 MiB      0.0 MiB          24                                   threshold_abs = max_treshold,
  4252   2052.2 MiB      0.0 MiB          24                                   labels = image[t],
  4253   2052.2 MiB      0.0 MiB          24                                   exclude_border=True
  4254                                                                        )
  4255                                         
  4256   2052.2 MiB      0.0 MiB          24           coords_with_time = np.column_stack((np.full(coords_t.shape[0], t), coords_t))
  4257   2052.2 MiB      0.0 MiB          24           coords_list.append(coords_with_time)
  4258                                         
  4259                                             # Combine all coordinates into a single array
  4260   2052.2 MiB      0.0 MiB           1       if len(coords_list) > 0:
  4261   2052.2 MiB      0.0 MiB           1           coords = np.vstack(coords_list)
  4262                                             else:
  4263                                                 coords = np.empty((0, 3), dtype=int)
  4264                                         
  4265   2052.4 MiB      0.1 MiB           1       mask = np.zeros(data.shape, dtype=bool)
  4266   2067.1 MiB     14.7 MiB           1       mask[tuple(coords.T)] = True
  4267                                         
  4268                                             # label peaks over time to ensure temporal consistency
  4269   2067.1 MiB      0.0 MiB           1       labels = label_peaks_over_time_3d(coords, max_dist=min_dist)
  4270   2067.1 MiB      0.0 MiB           1       markers = np.zeros(data.shape, dtype=int)
  4271   2261.1 MiB    194.1 MiB           1       markers[tuple(coords.T)] = labels
  4272                                         
  4273                                         
  4274                                             # define connectivity for 3D watershedding and perform watershedding
  4275   2261.1 MiB      0.0 MiB           1       conection = np.ones((3, 3, 3))
  4276   2548.8 MiB    287.7 MiB           2       watershed_results = watershed(image = np.array(data)*-1,  # watershedding field with maxima transformed to minima
  4277   2489.3 MiB      0.0 MiB           1                       markers = markers, # maximum points in 3D matrix
  4278   2489.3 MiB      0.0 MiB           1                       connectivity = conection, # connectivity
  4279   2489.3 MiB      0.0 MiB           1                       offset = (np.ones((3)) * 1).astype('int'), #4000/dx_m[dx]).astype('int'),
  4280   2489.3 MiB      0.0 MiB           1                       mask = image, # binary mask for areas to watershed on
  4281   2489.3 MiB      0.0 MiB           1                       compactness = 0) # high values --> more regular shaped watersheds
  4282                                         
  4283                                             # correct objects on date line if needed
  4284   2548.8 MiB      0.0 MiB           1       if connectLon == 1:
  4285   2548.8 MiB      0.0 MiB           1           if extension_size != 0:
  4286   2510.8 MiB    -38.0 MiB           1               watershed_results = np.array(watershed_results[:, :, extension_size:-extension_size])
  4287   2510.8 MiB      0.0 MiB           1           watershed_results = ConnectLon_on_timestep(watershed_results.astype("int"))
  4288                                         
  4289   2510.8 MiB      0.0 MiB           1       return watershed_results


        make sure that each object has at least one grid cell with more than min_pr threshold of precipitation
            Loop over 878 objects
        00:00:04.45
 
Save the object masks into a joint netCDF
Saved: moaap_output/202107_ERA5_ObjectMasks__dt-1h_MOAAP-masks.nc
        00:00:04.76
Filename: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  2147 1387.137 MiB 1387.137 MiB           1   @profile
  2148                                         def clean_up_objects(DATA,
  2149                                                              dT,
  2150                                                              min_tsteps = 0,
  2151                                                              obj_splitmerge = None):
  2152                                             """ Function to remove objects that are too short lived
  2153                                                 and to numerrate the object from 1...N
  2154                                             """
  2155                                             
  2156 1387.137 MiB    0.000 MiB           1       object_indices = ndimage.find_objects(DATA)
  2157 1387.137 MiB    0.000 MiB           1       MaxOb = np.max(DATA)
  2158 1387.137 MiB    0.000 MiB           1       MinLif = int(24 / dT)  # min lifetime of object to be split
  2159 1387.137 MiB    0.000 MiB           1       AVmax = 1.5
  2160                                         
  2161 1387.137 MiB    0.000 MiB           1       id_translate = np.zeros((len(object_indices),2))
  2162 1577.363 MiB  190.227 MiB           1       objectsTMP = np.zeros_like(DATA)
  2163 1577.363 MiB    0.000 MiB           1       ii = 1
  2164 1577.363 MiB    0.000 MiB        3672       for obj in range(len(object_indices)):
  2165 1577.363 MiB    0.000 MiB        3671           if object_indices[obj] != None:
  2166 1577.363 MiB    0.000 MiB         100               if object_indices[obj][0].stop - object_indices[obj][0].start >= min_tsteps / dT:
  2167 1577.363 MiB    0.000 MiB         100                   Obj_tmp = np.copy(objectsTMP[object_indices[obj]])
  2168 1577.363 MiB    0.000 MiB         100                   Obj_tmp[DATA[object_indices[obj]] == obj+1] = ii
  2169 1577.363 MiB    0.000 MiB         100                   objectsTMP[object_indices[obj]] = Obj_tmp
  2170 1577.363 MiB    0.000 MiB         100                   id_translate[obj,0] = obj+1
  2171 1577.363 MiB    0.000 MiB         100                   id_translate[obj,1] = ii
  2172 1577.363 MiB    0.000 MiB         100                   ii = ii + 1
  2173                                                     else:
  2174                                                         id_translate[obj,0] = obj+1
  2175                                                         id_translate[obj,1] = -1
  2176                                                 else:
  2177 1577.363 MiB    0.000 MiB        3571               id_translate[obj,0] = obj+1
  2178 1577.363 MiB    0.000 MiB        3571               id_translate[obj,1] = -1
  2179                                         
  2180                                             # adjust the directory strucutre accordingly
  2181 1577.363 MiB    0.000 MiB           1       obj_splitmerge_clean = {}
  2182                                         
  2183 1577.363 MiB    0.000 MiB           1       if obj_splitmerge != None:
  2184                                                 id_translate = id_translate.astype(int)  
  2185                                                 keys = np.copy(list(obj_splitmerge.keys()))
  2186                                                 for jj in range(len(keys)):
  2187                                                     obj_loc = np.where(int(list(keys)[jj]) == id_translate[:,0])[0][0]
  2188                                                     if id_translate[obj_loc,1] == -1:
  2189                                                         del obj_splitmerge[list(keys)[jj]]
  2190                                         
  2191                                                 # loop over objects and relable their indices if nescessary
  2192                                                 obj_splitmerge_clean = {}
  2193                                                 keys = np.copy(list(obj_splitmerge.keys()))
  2194                                                 core_translate = np.isin(id_translate[:,0], keys.astype(int))
  2195                                                 id_translate = id_translate[core_translate,:]
  2196                                                 for jj in range(len(keys)):
  2197                                                     obj_loc = np.where(int(list(keys)[jj]) == id_translate[:,0])[0][0]
  2198                                                     mergsplit = np.array(obj_splitmerge[keys[jj]])
  2199                                                     for kk in range(id_translate.shape[0]):
  2200                                                         mergsplit[np.isin(mergsplit, id_translate[kk,0])] = id_translate[kk,1]
  2201                                                     obj_splitmerge_clean[str(int(id_translate[obj_loc,1]))] = mergsplit
  2202                                                 
  2203 1577.363 MiB    0.000 MiB           1       return objectsTMP, obj_splitmerge_clean


Filename: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  2935  776.145 MiB  776.145 MiB           1   @profile
  2936                                         def mcs_tb_tracking(
  2937                                                             tb,
  2938                                                             pr,
  2939                                                             SmoothSigmaC,
  2940                                                             Pthreshold,
  2941                                                             CL_Area,
  2942                                                             CL_MaxT,
  2943                                                             Cthreshold,
  2944                                                             MinAreaC,
  2945                                                             MinTimeC,
  2946                                                             MCS_minPR,
  2947                                                             MCS_minTime,
  2948                                                             MCS_Minsize,
  2949                                                             dT,
  2950                                                             Area,
  2951                                                             connectLon,
  2952                                                             Gridspacing,
  2953                                                             breakup = 'watershed',  # method for breaking up connected objects [watershed, breakup]
  2954                                                            ):
  2955                                         
  2956  776.145 MiB    0.000 MiB           1       print('        track  clouds')
  2957  776.145 MiB    0.000 MiB           1       rgiObj_Struct=np.zeros((3,3,3)); rgiObj_Struct[:,:,:]=1
  2958                                             # Csmooth=gaussian_filter(tb, sigma=(0,SmoothSigmaC,SmoothSigmaC))
  2959  799.887 MiB   23.742 MiB           1       Cmask = (tb <= Cthreshold)
  2960  895.082 MiB   95.195 MiB           1       rgiObjectsC, nr_objectsUD = ndimage.label(Cmask, structure=rgiObj_Struct)
  2961  895.082 MiB    0.000 MiB           1       print('        '+str(nr_objectsUD)+' cloud object found')
  2962                                         
  2963                                             # if connectLon == 1:
  2964                                             #     # connect objects over date line
  2965                                             #     rgiObjectsC = ConnectLon(rgiObjectsC)
  2966                                                 
  2967                                                 
  2968  895.082 MiB    0.000 MiB           1       print('        fast way that removes obviously too small objects')
  2969  895.352 MiB    0.270 MiB           1       unique, counts = np.unique(rgiObjectsC, return_counts=True)
  2970  895.352 MiB    0.000 MiB           1       min_vol = np.round((CL_Area * (MCS_minTime/dT)) / ((Gridspacing / 1000.)**2)) # minimum grid cells requ. for MCS
  2971  895.352 MiB    0.000 MiB           1       remove = unique[counts < min_vol]
  2972  920.727 MiB   25.375 MiB           1       rgiObjectsC[np.isin(rgiObjectsC, remove)] = 0
  2973                                             
  2974 1015.703 MiB   94.977 MiB           1       C_objects, nr_objectsUD = ndimage.label(rgiObjectsC, structure=rgiObj_Struct)
  2975 1015.703 MiB    0.000 MiB           1       print('        '+str(nr_objectsUD)+' cloud object remaining')
  2976                                             
  2977                                             
  2978                                         #     print('        remove too small clouds')
  2979                                         #     Objects=ndimage.find_objects(rgiObjectsC)
  2980                                             
  2981                                         #     rgiAreaObj = np.array([[np.sum(Area[Objects[ob][1],Objects[ob][2]][rgiObjectsC[Objects[ob]][tt,:,:] == ob+1]) for tt in range(rgiObjectsC[Objects[ob]].shape[0])] for ob in range(nr_objectsUD)])
  2982                                         
  2983                                         #     # rgiVolObjC=np.array([np.sum(rgiObjectsC[Objects[ob]] == ob+1) for ob in range(nr_objectsUD)])
  2984                                         
  2985                                         #     # create final object array
  2986                                         #     C_objects=np.copy(rgiObjectsC); C_objects[:]=0
  2987                                         #     ii = 1
  2988                                         #     for ob in tqdm(range(len(rgiAreaObj))):
  2989                                         #         try:
  2990                                         #             AreaTest = np.max(np.convolve(np.array(rgiAreaObj[ob]) >= MinAreaC*1000**2, np.ones(int(MinTimeC/dT)), mode='valid'))
  2991                                         #         except:
  2992                                         #             stop()
  2993                                         #         if (AreaTest == int(MinTimeC/dT)) & (len(rgiAreaObj[ob]) >=int(MinTimeC/dT)):
  2994                                         #         # if rgiVolObjC[ob] >= MinAreaC:
  2995                                         #             C_objects[rgiObjectsC == (ob+1)] = ii
  2996                                         #             ii = ii + 1
  2997                                         
  2998 1015.703 MiB    0.000 MiB           1       print('        break up long living cloud shield objects with '+breakup+' that have many elements')
  2999 1015.703 MiB    0.000 MiB           1       if breakup == 'breakup':
  3000                                                 C_objects, object_split = BreakupObjects(C_objects,
  3001                                                                             int(MinTimeC/dT),
  3002                                                                             dT)
  3003 1015.703 MiB    0.000 MiB           1       elif breakup == 'watershed':
  3004                                                 # C_objects = watersheding(C_objects,
  3005                                                 #                6,  # at least six grid cells apart 
  3006                                                 #                1)
  3007 1015.703 MiB    0.000 MiB           1           threshold=1
  3008 1015.703 MiB    0.000 MiB           1           min_dist=int(((CL_Area/np.pi)**0.5)/(Gridspacing/1000))*2
  3009 1205.867 MiB  190.164 MiB           1           tb_masked = np.copy(tb)
  3010                                                 # we have to make minima (cold cloud tops) to maxima
  3011 1205.891 MiB    0.023 MiB           1           tb_masked = tb_masked * -1
  3012                                                 # tb_masked = tb_masked + np.nanmin(tb_masked)
  3013                                                 # tb_masked[C_objects == 0] = 0
  3014 1330.637 MiB  -65.340 MiB           2           C_objects = watershed_3d_overlap(
  3015 1395.977 MiB  190.086 MiB           1                   tb * -1,
  3016 1395.977 MiB    0.000 MiB           1                   Cthreshold * -1,
  3017 1395.977 MiB    0.000 MiB           1                   Cthreshold * -1, #CL_MaxT * -1,
  3018 1395.977 MiB    0.000 MiB           1                   min_dist,
  3019 1395.977 MiB    0.000 MiB           1                   dT,
  3020 1395.977 MiB    0.000 MiB           1                   mintime = MinTimeC,
  3021 1395.977 MiB    0.000 MiB           1                   connectLon = connectLon,
  3022 1395.977 MiB    0.000 MiB           1                   extend_size_ratio = 0.10
  3023                                                         )
  3024                                                 
  3025                                             # if connectLon == 1:
  3026                                             #     print('        connect cloud objects over date line')
  3027                                             #     C_objects = ConnectLon_on_timestep(C_objects)
  3028                                         
  3029                                             # check if precipitation object is from an MCS
  3030 1331.762 MiB    1.125 MiB           1       object_indices = ndimage.find_objects(C_objects)
  3031 1331.762 MiB    0.000 MiB           1       MCS_objects_Tb = np.zeros(C_objects.shape,dtype=int)
  3032                                         
  3033 1387.137 MiB    0.375 MiB        4281       for iobj,_ in tqdm(enumerate(object_indices)):
  3034 1387.137 MiB    0.000 MiB        4280           if object_indices[iobj] is None:
  3035 1387.137 MiB    0.000 MiB         708               continue
  3036                                         
  3037 1387.137 MiB    0.000 MiB        3572           time_slice = object_indices[iobj][0]
  3038 1387.137 MiB    0.000 MiB        3572           lat_slice  = object_indices[iobj][1]
  3039 1387.137 MiB    0.000 MiB        3572           lon_slice  = object_indices[iobj][2]
  3040                                         
  3041 1387.137 MiB    0.000 MiB        3572           tb_object_slice= C_objects[object_indices[iobj]]
  3042 1387.137 MiB    0.000 MiB        3572           tb_object_act = np.where(tb_object_slice==iobj+1,True,False)
  3043 1387.137 MiB    0.000 MiB        3572           if len(tb_object_act) < MCS_minTime:
  3044 1387.137 MiB    0.000 MiB        1307               continue
  3045                                         
  3046 1387.137 MiB    0.000 MiB        2265           tb_slice =  tb[object_indices[iobj]]
  3047 1387.137 MiB    0.000 MiB        2265           tb_act = np.copy(tb_slice)
  3048 1387.137 MiB    0.000 MiB        2265           tb_act[~tb_object_act] = np.nan
  3049                                         
  3050 1387.137 MiB    0.000 MiB        2265           bt_object_slice = C_objects[object_indices[iobj]]
  3051 1387.137 MiB    0.000 MiB        2265           bt_object_act = np.copy(bt_object_slice)
  3052 1387.137 MiB    0.000 MiB        2265           bt_object_act[~tb_object_act] = 0
  3053                                         
  3054 1387.137 MiB    0.000 MiB        2265           area_act = np.tile(Area[lat_slice, lon_slice], (tb_act.shape[0], 1, 1))
  3055 1387.137 MiB    0.000 MiB        2265           area_act[~tb_object_act] = 0
  3056                                         
  3057                                                 ### Calculate cloud properties
  3058 1387.137 MiB    0.000 MiB        2265           tb_size = np.array(np.sum(area_act,axis=(1,2)))
  3059 1387.137 MiB    0.000 MiB        2265           tb_min = np.array(np.nanmin(tb_act,axis=(1,2)))
  3060                                         
  3061                                                 ### Calculate precipitation properties
  3062 1387.137 MiB    0.000 MiB        2265           pr_act = np.copy(pr[object_indices[iobj]])
  3063 1387.137 MiB    0.000 MiB        2265           pr_act[tb_object_act == 0] = np.nan
  3064                                         
  3065 1387.137 MiB    0.000 MiB        2265           pr_peak_act = np.array(np.nanmax(pr_act,axis=(1,2)))
  3066                                         
  3067 1387.137 MiB    0.000 MiB        2265           pr_region_act = pr_act >= Pthreshold #*dT
  3068 1387.137 MiB    0.000 MiB        2265           area_act = np.tile(Area[lat_slice, lon_slice], (tb_act.shape[0], 1, 1))
  3069 1387.137 MiB    0.000 MiB        2265           area_act[~pr_region_act] = 0
  3070 1387.137 MiB    0.000 MiB        2265           pr_under_cloud = np.array(np.sum(area_act,axis=(1,2)))/1000**2 
  3071                                         
  3072                                                 # Test if object classifies as MCS
  3073 1387.137 MiB    0.000 MiB        2265           tb_size_test = np.max(np.convolve((tb_size / 1000**2 >= CL_Area), np.ones(MCS_minTime), 'valid') / MCS_minTime) == 1
  3074 1387.137 MiB    0.000 MiB        2265           tb_overshoot_test = np.max((tb_min  <= CL_MaxT )) == 1
  3075 1387.137 MiB    0.000 MiB        2265           pr_peak_test = np.max(np.convolve((pr_peak_act >= MCS_minPR ), np.ones(MCS_minTime), 'valid') / MCS_minTime) ==1
  3076 1387.137 MiB    0.000 MiB        2265           pr_area_test = np.max((pr_under_cloud >= MCS_Minsize)) == 1
  3077 1387.137 MiB    0.000 MiB        2265           MCS_test = (
  3078 1387.137 MiB    0.000 MiB        9060                       tb_size_test
  3079 1387.137 MiB    0.000 MiB        2265                       & tb_overshoot_test
  3080 1387.137 MiB    0.000 MiB        2265                       & pr_peak_test
  3081 1387.137 MiB    0.000 MiB        2265                       & pr_area_test
  3082                                                 )
  3083                                         
  3084                                                 # assign unique object numbers
  3085 1387.137 MiB    0.000 MiB        2265           tb_object_act = np.array(tb_object_act).astype(int)
  3086 1387.137 MiB    0.000 MiB        2265           tb_object_act[tb_object_act == 1] = iobj + 1
  3087                                         
  3088                                         #         window_length = int(MCS_minTime / dT)
  3089                                         #         moving_averages = np.convolve(MCS_test, np.ones(window_length), 'valid') / window_length
  3090                                         
  3091 1387.137 MiB    0.000 MiB        2265           if MCS_test == 1:
  3092 1387.137 MiB    0.000 MiB         100               TMP = np.copy(MCS_objects_Tb[object_indices[iobj]])
  3093 1387.137 MiB    0.000 MiB         100               TMP = TMP + tb_object_act
  3094 1387.137 MiB   55.000 MiB         100               MCS_objects_Tb[object_indices[iobj]] = TMP
  3095                                         
  3096                                                 else:
  3097                                                     # print([tb_size_test,tb_overshoot_test,pr_peak_test,pr_area_test])
  3098 1387.137 MiB    0.000 MiB        2165               continue
  3099                                         
  3100 1522.449 MiB 1522.449 MiB           2       MCS_objects_Tb, _ = clean_up_objects(MCS_objects_Tb,
  3101 1387.137 MiB    0.000 MiB           1                                              dT,
  3102 1387.137 MiB    0.000 MiB           1                                              min_tsteps=int(MCS_minTime/dT))
  3103                                         
  3104 1522.449 MiB    0.000 MiB           1       return MCS_objects_Tb, C_objects


Filename: /home/raphael/Documents/Studium/9.Semester/Semester_thesis/Semester-thesis/Tracking_Functions.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  3108 1415.551 MiB 1415.551 MiB           1   @profile
  3109                                         def cloud_tracking(
  3110                                             tb,
  3111                                             pr,
  3112                                             # MCS_obj,
  3113                                             connectLon,
  3114                                             Gridspacing,
  3115                                             dT,
  3116                                             tb_threshold = 241,
  3117                                             tb_overshoot = 235,
  3118                                             erosion_disk = 1.5,
  3119                                             min_dist = 8
  3120                                             ):
  3121                                             
  3122                                             """
  3123                                             Tracks clouds from hourly or sub-hourly brightness temperature data.
  3124                                             Calculates cloud statistics, including their precipitation (pr) properties if pr is provided.
  3125                                         
  3126                                             Args:
  3127                                                 tb (float): brightness temperature of dimension [time,lat,lon]
  3128                                                 connectLon (bol): 1 means that clouds should be connected accross date line
  3129                                                 Gridspacing (float): average horizontal grid spacing in [m]
  3130                                                 tb_threshold (float, optional): tb threshold to define cloud mask. Default is "241".
  3131                                                 cloud_overshoot (float, optional): tb threshold to find local minima for watershedding. Default is "235".
  3132                                                 erosion_disk (float, optional): reduction of next timestep mask for temporal connection of features. Larger values result in more erosion and can remove smaller clouds. The default is "0.15".
  3133                                                 min_dist (int, optional): minimum distance in grid cells between two tb minima (overshoots). The default is "8".
  3134                                         
  3135                                             Returns:
  3136                                                 float: The product of `a` and `b`.
  3137                                             """
  3138                                         
  3139 1415.551 MiB    0.000 MiB           1       CL_Area = min_dist * Gridspacing
  3140 1415.551 MiB    0.000 MiB           1       breakup = 'watershed'
  3141                                             
  3142 1415.551 MiB    0.000 MiB           1       print('        track  clouds')
  3143 1415.551 MiB    0.000 MiB           1       Cmask = (tb <= tb_threshold)
  3144                                             
  3145 1415.551 MiB    0.000 MiB           1       print('        break up long living cloud shield objects with wathershedding')
  3146                                             
  3147 1415.551 MiB    0.000 MiB           1       min_dist=int(((CL_Area/np.pi)**0.5)/(Gridspacing/1000))*2
  3148 1605.645 MiB  190.094 MiB           1       tb_masked = np.copy(tb)
  3149                                             # we have to make minima (cold cloud tops) to maxima
  3150 1605.738 MiB    0.094 MiB           1       tb_masked = tb_masked * -1
  3151                                             # tb_masked = tb_masked + np.nanmin(tb_masked)
  3152                                             # tb_masked[C_objects == 0] = 0
  3153 1783.410 MiB  -12.344 MiB           2       cloud_objects = watershed_3d_overlap(
  3154 1795.754 MiB  190.016 MiB           1               tb * -1,
  3155 1795.754 MiB    0.000 MiB           1               tb_threshold * -1,
  3156 1795.754 MiB    0.000 MiB           1               tb_overshoot * -1, #CL_MaxT * -1,
  3157 1795.754 MiB    0.000 MiB           1               min_dist,
  3158 1795.754 MiB    0.000 MiB           1               dT,
  3159 1795.754 MiB    0.000 MiB           1               mintime = 0,
  3160 1795.754 MiB    0.000 MiB           1               connectLon = connectLon,
  3161 1795.754 MiB    0.000 MiB           1               extend_size_ratio = 0.10,
  3162                                                     # erosion_disk = erosion_disk
  3163                                                     )
  3164                                         
  3165 1783.410 MiB    0.000 MiB           1       print("        make sure that each object has at least one grid cell with more than min_pr threshold of precipitation")
  3166 1783.410 MiB    0.000 MiB           1       min_pr = 2 * dT # minimum precipitation in [mm/h]
  3167 1783.410 MiB    0.000 MiB           1       object_indices = ndimage.find_objects(cloud_objects)
  3168 1783.410 MiB    0.000 MiB         879       for iobj,_ in tqdm(enumerate(object_indices)):
  3169 1783.410 MiB    0.000 MiB         878           if object_indices[iobj] is None:
  3170 1783.410 MiB    0.000 MiB         140               continue
  3171 1783.410 MiB    0.000 MiB         738           pr_object_slice= cloud_objects[object_indices[iobj]]
  3172 1783.410 MiB    0.000 MiB         738           pr_object_act = np.where(pr_object_slice==iobj+1,True,False)
  3173                                                     
  3174 1783.410 MiB    0.000 MiB         738           pr_slice =  pr[object_indices[iobj]]
  3175 1783.410 MiB    0.000 MiB         738           pr_act = np.copy(pr_slice)
  3176 1783.410 MiB    0.000 MiB         738           pr_act[~pr_object_act] = np.nan
  3177 1783.410 MiB    0.000 MiB         738           if np.nanmax(pr_act) < min_pr:
  3178 1783.410 MiB    0.000 MiB         218               cloud_objects[object_indices[iobj]][cloud_objects[object_indices[iobj]] == iobj+1] = 0
  3179                                         
  3180 1783.410 MiB    0.000 MiB           1       return cloud_objects


